/*
 * generated by Xtext 2.20.0
 */
package org.qdt.quingo.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.qdt.quingo.quingo.QuingoPackage
import org.qdt.quingo.quingo.BlockStatement
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.IScope
import org.qdt.quingo.quingo.LocalVarDecl
import org.qdt.quingo.quingo.UsingStatement
import org.qdt.quingo.quingo.FunDeclaration
import org.qdt.quingo.quingo.Program
import org.qdt.quingo.quingo.ForStatement
import java.util.ArrayList
import org.qdt.quingo.quingo.VariableName

/**
 * Custom scoping for Quingo variables declared in a For statement.
 * <p>
 * Scope is the range in which a symbol can be linked to. See 
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping for
 * details.
 * <p>
 * Example: {@code for (int i=0; i<5; i++) }. The variable {@code i} can be used in the
 * loop body. However, the default scoping rules of XText do not support it. Therefore,
 * we extend the {@code AbstractQuingoScopeProvider} class to implement the desired scope
 * rule.
 * 
 * @author Jintao Yu
 */
class QuingoScopeProvider extends AbstractQuingoScopeProvider {
	/**
	 * Returns a scope for the given context.
	 * <p>
	 * The scope provides access to the compatible visible EObjects for a given reference.
	 *
	 * @param context    the element from which an element shall be referenced. 
	 * @param reference  the reference for which to get the scope.
	 * @return {@link IScope} representing the innermost {@link IScope} for the passed 
	 *         context and reference.
	 */
	override getScope(EObject context, EReference reference) {
		if (reference == QuingoPackage.eINSTANCE.expVariable_Value) {
			return scopeForVariable(context, reference)
		}
		return super.getScope(context, reference)
	}
	
	/**
	 * The scope provider for variables.
	 * <p>
	 * Specially, the function include the variable declared in the 'init' part of a For loop
	 * in the scope of variables in the loop body.
	 *
	 * @param context    the element from which an element shall be referenced. 
	 * @param reference  the reference for which to get the scope.
	 * @return {@link IScope} representing the innermost {@link IScope} for the passed 
	 *         context and reference.
	 */
	def IScope scopeForVariable(EObject context, EReference reference) {
		val container = context.eContainer
		if (container instanceof BlockStatement) {
			var locals = container.stats.takeWhile[it != context].filter(LocalVarDecl)
			var list = new ArrayList<VariableName>
			for (local: locals) {
				for (init: local.init) {
					list.add(init.varName)
				}
			}
			return Scopes.scopeFor(list, scopeForVariable(container, reference))
		}
		else if (container instanceof ForStatement) {
			var forInit = container.initExpression
			if (forInit instanceof LocalVarDecl) {
				var list = new ArrayList<VariableName>
				for (init: forInit.init) {
					list.add(init.varName)
				}
				return Scopes.scopeFor(list, scopeForVariable(container, reference))
			}
			else {
				return scopeForVariable(container, reference)
			}
		}
		else if (container instanceof UsingStatement) {
			return Scopes.scopeFor(container.pars, scopeForVariable(container, reference))
		}
		else if (container instanceof FunDeclaration) {
			return Scopes.scopeFor(container.pars, scopeForVariable(container, reference))
		}
		else if (container instanceof Program) {
			return super.getScope(container, reference)
		}
		else {
			return scopeForVariable(container, reference)
		}
	}
}
