/*
 * generated by Xtext 2.20.0
 */
package org.qdt.quingo.generator

import java.io.IOException
import java.util.ArrayList
import java.util.HashMap
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.qdt.quingo.quingo.Add
import org.qdt.quingo.quingo.And
import org.qdt.quingo.quingo.ArrayAccess
import org.qdt.quingo.quingo.ArrayType
import org.qdt.quingo.quingo.BlockStatement
import org.qdt.quingo.quingo.BoolType
import org.qdt.quingo.quingo.BooleanLiteral
import org.qdt.quingo.quingo.BreakStatement
import org.qdt.quingo.quingo.ContinueStatement
import org.qdt.quingo.quingo.Equal
import org.qdt.quingo.quingo.ExpArray
import org.qdt.quingo.quingo.ExpFunctionCall
import org.qdt.quingo.quingo.ExpLength
import org.qdt.quingo.quingo.ExpTuple
import org.qdt.quingo.quingo.ExpVariable
import org.qdt.quingo.quingo.Expression
import org.qdt.quingo.quingo.FormalParameter
import org.qdt.quingo.quingo.FunDeclaration
import org.qdt.quingo.quingo.FunctionCall
import org.qdt.quingo.quingo.FunctionType
import org.qdt.quingo.quingo.IfStatement
import org.qdt.quingo.quingo.IntLiteral
import org.qdt.quingo.quingo.IntType
import org.qdt.quingo.quingo.Mult
import org.qdt.quingo.quingo.NEqual
import org.qdt.quingo.quingo.Or
import org.qdt.quingo.quingo.Program
import org.qdt.quingo.quingo.QubitType
import org.qdt.quingo.quingo.QuingoFactory
import org.qdt.quingo.quingo.ReturnStatement
import org.qdt.quingo.quingo.SwitchStatement
import org.qdt.quingo.quingo.TupleType
import org.qdt.quingo.quingo.Type
import org.qdt.quingo.quingo.Unary
import org.qdt.quingo.quingo.UnitType
import org.qdt.quingo.quingo.UsingStatement
import org.qdt.quingo.quingo.WaitStatement
import org.qdt.quingo.quingo.WhileStatement
import org.qdt.quingo.quingo.OpAssignment
import org.qdt.quingo.quingo.LocalVarDecl
import org.qdt.quingo.quingo.Assignment
import org.qdt.quingo.quingo.EmptyStatement
import org.qdt.quingo.quingo.DoubleLiteral
import org.qdt.quingo.quingo.DoubleType
import java.util.HashSet
import org.qdt.quingo.quingo.Statement
import org.qdt.quingo.quingo.ForStatement
import org.qdt.quingo.quingo.VariableInit
import org.qdt.quingo.quingo.Opaque
import org.qdt.quingo.typing.QuingoSemantics
import com.google.inject.Inject
import org.eclipse.xtext.nodemodel.ICompositeNode
import org.qdt.quingo.quingo.ToInt
import org.qdt.quingo.quingo.ToDouble
import org.qdt.quingo.quingo.TimerDeclaration
import org.qdt.quingo.quingo.TimingConstraint
import org.qdt.quingo.quingo.Variable

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class QuingoGenerator extends AbstractGenerator {
	
	// sizes of primitive data types in bytes
	val BOOL_SIZE = 1
	val INT_SIZE = 4
	val POINTER_SIZE = 4
	val DOUBLE_SIZE = 4
	
	// global variables
	int sIndex // the first unused S register
	int iIndex // the first unused R register
	int fIndex // the first unused F register
	String duration // the duration of current quantum operation
	
	int ifIndex		// used for the generated labels related to IF structures
	int whileIndex	// used for the generated labels related to WHILE and FOR structures
	int switchIndex // used for the generated labels related to SWITCH structures
	int arrayIndex	// used for the generated labels related to array allocation
	int funIndex	// used for the generated labels related to function calls
	
	HashMap<String, Opaque> config		// opaque gates configuration
	HashMap<EObject, Integer> indexMap	// match an AST node to its index
	HashMap<String, MetaData> regToMeta	// record the MetaData that is stored in the registers
	HashMap<TimerDeclaration, Integer> timerMap

	int memoryAddr	// the beginning of memory space
	String output	// buffer for the code generation
	IFileSystemAccess2 fsaGlobal
	String fileName
	Boolean left	// specify whether the current expression is on the left side in an assignment statement
	int global
	
	var vscode = false
	
	@Inject	QuingoSemantics xsemantics

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		// Global variable initialization
		sIndex = 0
		iIndex = 3 // r0 for false, r1 for true, r2 for freeAddr
		fIndex = 1 // f0 for 0.0
		duration = "1, "

		ifIndex = 0
		whileIndex = 1 // must be positive since its sign is used in compiling CONTINUE statements 
		arrayIndex = 0
		switchIndex = 0
		funIndex = 0

		config = new HashMap<String, Opaque>
		indexMap = new HashMap<EObject, Integer>
		regToMeta = new HashMap<String, MetaData>
		timerMap = new HashMap<TimerDeclaration, Integer>

		memoryAddr = Configuration.staticAddr + INT_SIZE // [Configuration.staticAddr] = 0
		output = ""
		fsaGlobal = fsa
		left = false
		global = 0
		
		var resourceSet = resource.resourceSet
		for (res : resourceSet.resources) {
			if (res.URI.fileExtension == "qfg") {
				var prog = res.contents.head as Program
				for (opaque: prog?.eAllContents.toIterable.filter(Opaque))
					config.put(opaque.name, opaque)
			}
		}
		
		for (fun : resource.allContents.toIterable.filter(FunDeclaration)) {
			if (fun.name.equals("main")) {
	        	output += "XOR r0, r0, r0\n"
	        	output += "ADDI r1, r0, 1\n"
	        	valueToReg("r2", Configuration.dynamicAddr)
	        	output += "SW r0, " + Configuration.staticAddr + "(r0)\n"
	        	output += "FCVT.S.W f0, r0\n"
	        	
	        	if (vscode) {
					System.err.println("input: " + resource.URI);
					for (res : resourceSet.resources) {
						System.err.println("Resource set: " + res.URI);
					}
	        	}

				if (Configuration.outputFile != "") {
					fileName = Configuration.outputFile
				}
				else {
					fileName = "build/" + resource.URI.trimFileExtension.lastSegment + ".eqasm"
				}
				try {
			        var map = new HashMap<String, MetaData>
			        for (par: fun.pars) { 
			        	par.compile(map)
			        }
			        fun.block?.compile(map)
				}
				catch (Exception e) {
					System.err.println(e + ", reported by line " + e.getStackTrace.get(0).getLineNumber)
					Configuration.exitCode = -6
				}
				output += "function_null_end:\n"
				output += "STOP\n"
				writeFile
			}
		}
	}

    def dispatch MetaData compile(FormalParameter stat, HashMap<String, MetaData> map) {
		while (map.containsKey(stat.name)) {
			stat.name = stat.name + "-2";
		}
		return allocateRegister(stat.name, stat.type, map)
	}
	
	def dispatch MetaData compile(LocalVarDecl stat, HashMap<String, MetaData> map) {
		for (init: stat.init) {
			init.compile(map)
		}
		return null
	}
	
	def dispatch MetaData compile(VariableInit variable, HashMap<String, MetaData> map) {
		var varName = variable.varName
		while (map.containsKey(varName.name)) {
			varName.name = varName.name + "-2";
		}
		var type = (variable.eContainer as LocalVarDecl).type
		var meta = allocateRegister(varName.name, type, map)
		if (variable.value !== null) {
			assignMetaData(meta, variable.value.compile(map), type, NodeModelUtils.getNode(variable))
		}
		return meta
	}
	
	def MetaData allocateRegister(String name, Type type, HashMap<String, MetaData> map) {
		var meta = getScalaMeta(type)
		createMetaData(meta, type, map)
		if (xsemantics.isQubitTypes(type) || type instanceof FunctionType) {
			meta.type = QuingoFactory::eINSTANCE.createQubitType
		}
		map.put(name, meta)
		return meta
	}
	
	def void createMetaData(MetaData meta, Type type, HashMap<String, MetaData> map) {
		if (type instanceof ArrayType) {
			
			// Get the actual length and ptype
			var length = type.length
			var ptype = type.ptype
			while (ptype instanceof ArrayType) {
				var temp = ptype.length
				ptype.setLength(length)
				length = temp
				ptype = ptype.ptype
			}

			// Store the actual address of the array
			var reg = meta.register
			valueToReg(reg, memoryAddr)
			
			// Decide the length of the array
			var intlen = 0
			var const = true
			if (length !== null) {
				var lengMeta = length.compile(map)
				if (lengMeta.valid.constant) {
					intlen = (lengMeta.value as Integer).intValue
				}
				if (intlen >= Configuration.maxUnrolling || (meta.value instanceof Integer && (meta.value as Integer) < 0)) {
					const = false
					meta.valid.setOnlyReg
					
					// Allocate memory for the array
					output += "ADDI " + reg + ", r2, 0\n"
					var lreg = lengMeta.register
					output += "SW " + lreg + ", 0(" + reg + ")\n"
					updateFreeAddr(type.ptype, lengMeta)
					
					if (type.ptype instanceof ArrayType) {
						// set initial values
						var rshift = getNewReg
						output += "ADDI " + rshift + ", " + reg + ", " + INT_SIZE + "\n"
						var rindex = getNewReg
						output += "ADDI " + rindex + ", r0, 0\n" // rindex = 0
						
						// while (i<length) {
						var label = arrayIndex++
						output += "ARRAY_" + label + ":\n"
						var flag = getNewReg
						lreg = lengMeta.register
						output += "CMP " + rindex + ", " + lreg + "\nNOP\n"
						output += "FBR LE, " + flag + "\n"
						output += "BNE " + flag + ", r1, ARRAY_" + label + "_END\n"
						
						// allocate recursively
						var cmeta = getScalaMeta(type.ptype)
						cmeta.value = -1
						createMetaData(cmeta, type.ptype, map)
						var creg = cmeta.register
						output += "SW " + creg + ", 0(" + rshift + ")\n"
						
						// increase the index
						output += "ADDI " + rshift + ", " + rshift + ", " + POINTER_SIZE + "\n"
						output += "ADDI " + rindex + ", " + rindex + ", " + 1 + "\n"
						output += "BEQ r0, r0, ARRAY_" + label + "\n" //}
						output += "ARRAY_" + label + "_END:\n"
					}
				}
			}
			
			if (const) {
				meta.valid.setConAndReg
				meta.value = intlen
					
				// Allocate memory for the array
				var addr = memoryAddr + INT_SIZE
				var size = dataSize(ptype)
				memoryAddr = addr + intlen * size
				
				// Create array members
				meta.link = new ArrayList<MetaData>
				for (var i=0; i<intlen; i++) {
					var cmeta = getScalaMeta(type.ptype)
					cmeta.address = addr
					addr += size
					createMetaData(cmeta, type.ptype, map)
					meta.link.add(cmeta)
				}
			}
			
			// Restore the original type
			var atype = ptype.eContainer as ArrayType
			while (atype !== type) {
				var temp = atype.length
				atype.setLength(length)
				length = temp
				atype = atype.eContainer as ArrayType
			}
			type.setLength(length)
		}
	}
	
	def MetaData allocateArray(ArrayType type, int depth, int level, HashMap<String, MetaData> map) {
		var array = new MetaData
		var reg = array.register

		// get array's length
		var Type ptype = type
		for (var i=0; i<depth-level-1; i++) {
			ptype = (ptype as ArrayType).ptype
		}
		var length = (ptype as ArrayType).length

		// get array's type
		ptype = type.ptype
		for (var i=0; i<level; i++) {
			ptype = (ptype as ArrayType).ptype
		}

		var MetaData lengMeta = null
		if (length === null) {
			array.value = 0
			array.valid.setOnlyConstant
			array.link = new ArrayList<MetaData>
			array.address = memoryAddr
			memoryAddr += POINTER_SIZE
			valueToReg(reg, memoryAddr)
			output += "SW " + reg + ", " + hex(array.address) + "(r0)\n"
			memoryAddr += INT_SIZE
			array.type = QuingoFactory::eINSTANCE.createArrayType
			return array
		}
		else {
			lengMeta = length.compile(map)

			if (lengMeta.valid.constant) {
				array.address = memoryAddr
				var addr = memoryAddr + POINTER_SIZE
				valueToReg(reg, addr)
				output += "SW " + reg + ", " + hex(array.address) + "(r0)\n"
				addr += INT_SIZE
				var size = dataSize(ptype)
				var intlen = (lengMeta.value as Integer).intValue
				memoryAddr = addr + intlen * size
				array.value = lengMeta.value
				array.valid.setOnlyConstant
				array.link = new ArrayList<MetaData>
				array.type = QuingoFactory::eINSTANCE.createArrayType
				for (var i=0; i<intlen; i++) {
					var MetaData meta
					if (ptype instanceof ArrayType) {
						meta = allocateArray(type, depth, level + 1, map)
					}
					else {
						//meta = createMetaData(ptype, map)
					}
					meta.address = addr
					addr += size
					array.link.add(meta)
				}
			}
			else if (ptype instanceof ArrayType) {
				array.valid.reg = true
				array.type = QuingoFactory::eINSTANCE.createArrayType

				output += "ADDI " + reg + ", r2, 0\n"
				var lreg = lengMeta.register
				output += "SW " + lreg + ", 0(" + reg + ")\n"
				updateFreeAddr(ptype, lengMeta)
				
				// set initial values
				var rshift = getNewReg
				output += "ADDI " + rshift + ", " + reg + ", " + INT_SIZE + "\n"
				var rindex = getNewReg
				output += "ADDI " + rindex + ", r0, 0\n" // rindex = 0
				
				// while (i<length) {
				var label = arrayIndex++
				output += "ARRAY_" + label + ":\n"
				var flag = getNewReg
				lreg = lengMeta.register
				output += "CMP " + rindex + ", " + lreg + "\nNOP\n"
				output += "FBR LE, " + flag + "\n"
				output += "BNE " + flag + ", r1, ARRAY_" + label + "_END\n"
				
				// allocate recursively
				var lmeta = allocateArray(type, depth, level + 1, map)
				output += "SW " + lmeta.reg + ", 0(" + rshift + ")\n"
				
				// increase the index
				output += "ADDI " + rshift + ", " + rshift + ", " + POINTER_SIZE + "\n"
				output += "ADDI " + rindex + ", " + rindex + ", " + 1 + "\n"
				output += "BEQ r0, r0, ARRAY_" + label + "\n" //}
				output += "ARRAY_" + label + "_END:\n"
			}
		}

		return array
	}
	
	def void updateFreeAddr(Type type, MetaData lengMeta) {
		var size = dataSize(type)
		if (lengMeta.valid.constant) {
			var length = (lengMeta.value as Integer).intValue * size + INT_SIZE
			output += "ADDI r2, r2, " + length + "\n" // r2 += length
			return
		}
		var lreg = lengMeta.register
		if (size === 1) {
			output += "ADD r2, r2, " + lreg + "\n" // r2 += length
		}
		else {
			var rlength = getNewReg
			valueToReg(rlength, size) // length = single
			output += "MUL " + rlength + ", " + rlength + ", " + lreg + "\n" // length = single*num
			output += "ADD r2, r2, " + rlength + "\n" // r2 += length
		}
		output += "ADDI r2, r2, " + INT_SIZE + "\n" // 4 bytes are used for storing the length
	}
	
	def dispatch MetaData compile(BlockStatement stat, HashMap<String, MetaData> map) {
		if (stat.stats !== null) {
			for (st: stat.stats) {
				var meta = st.compile(map)
				if (meta !== null) {
					return meta
				}
			}
		}
		return null
	}
	
	def dispatch MetaData compile(WaitStatement stat, HashMap<String, MetaData> map) {
		var meta = stat.lis.get(stat.lis.length - 1).compile(map)
		if (meta.valid.constant) {
			output += "QWAIT " + meta.value + "\n"
		}
		else {
			var reg = meta.register
			output += "QWAITR " + reg + "\n"
		}
		return null
	}
	
	def dispatch MetaData compile(ReturnStatement stat, HashMap<String, MetaData> map) {
		var container = stat.eContainer
		while (!(container instanceof FunDeclaration)) {
			container = container.eContainer
		}
		var MetaData rmeta = null
		if (stat.value !== null) {
			rmeta = stat.value.compile(map)
			var fun = container as FunDeclaration
			if (fun.name.equals("main")) {
				var ptr = new MetaData
				ptr.type = new PointerType
				ptr.value = 0
				var reg = ptr.register
				ptr.valid.setOnlyReg
				valueToReg(reg, Configuration.sharedAddr)
				
				var free = new MetaData
				free.type = new PointerType
				free.value = 0
				var rfree = free.register
				valueToReg(rfree, Configuration.sharedAddr)
				free.valid.setOnlyReg
				exportMetaData(ptr, free, rmeta, fun.type)
			}
			else {
				if (!(fun.type instanceof UnitType)) {
					var ret = map.get("return")
					assignMetaData(ret, rmeta, fun.type, NodeModelUtils.getNode(stat))
				}
			}
		}
		else {
			rmeta = new MetaData
		}
		var index = indexMap.get(container)
		output += "BEQ r0, r0, function_" + index + "_end\n"
		return rmeta
	}
	
	def void exportMetaData(MetaData ptr, MetaData free, MetaData meta, Type type) {
		var intValue = (ptr.value as Integer).intValue
		var freeValue = (free.value as Integer).intValue
		freeValue = Math.max(freeValue, intValue + dataSize(type))
		free.value = freeValue
		var op = storeOp(type)
		
		if (type instanceof TupleType) {
			var ttype = (type as TupleType).type
			for (var i=0; i<ttype.length; i++) {
				exportMetaData(ptr, free, meta.link.get(i), ttype.get(i))
				ptr.value = (ptr.value as Integer).intValue + dataSize(ttype.get(i))
			}
		}
		else if (type instanceof ArrayType) {
			var ptype = (type as ArrayType).ptype
			var psize = dataSize(ptype)
			if (meta.valid.constant) {
				// Store the offset
				var reg = getNewReg
				valueToReg(reg, freeValue - intValue)
				var preg = ptr.register
				output += "SW " + reg + ", " + intValue + "(" + preg + ")\n"

				// Store the length
				var length = meta.value as Integer
				valueToReg(reg, length)
				output += "SW " + reg + ", " + freeValue + "(" + preg + ")\n"
				
				// Update the pointers
				ptr.value = freeValue + INT_SIZE
				free.value = freeValue + length * psize
				
				for (member : meta.link) {
					exportMetaData(ptr, free, member, ptype)
					ptr.value = (ptr.value as Integer) + psize
				}
			}
			else {
				for (m : regToMeta.values) {
					m.storeToMem
				}
				meta.storeToMem
				var preg = ptr.register
				output += "ADDI " + preg + ", " + preg + ", " + (ptr.value as Integer).intValue + "\n"
				var freg = free.register
				output += "ADDI " + freg + ", " + freg + ", " + (free.value as Integer).intValue + "\n"
				var raddr = getScalaMeta(meta.type)
				var rreg = raddr.register
				valueToReg(rreg, meta.address)
				exportMetaData(preg, freg, rreg, type)
				
				// Remove the offset from the pointer register
				output += "ADDI " + preg + ", " + preg + ", " + -(ptr.value as Integer).intValue + "\n"
				ptr.valid.setOnlyReg
				output += "ADDI " + freg + ", " + freg + ", " + -(free.value as Integer).intValue + "\n"
				free.valid.setOnlyReg
			}
		}
		else if (type instanceof BoolType) {
			var String src
			if (meta.valid.constant) {
				src = (meta.value as Boolean)? "r1": "r0"
			}
			else {
				src = meta.register
			}
			var preg = ptr.register
			output += "SB " + src + ", 0x" + Integer.toHexString(intValue) + "(" + preg + ")\n"
		}
		else if (type instanceof DoubleType) {
			var temp = getNewReg
			if (meta.valid.constant) {
				valueToReg(temp, Float.floatToIntBits(meta.value as Float))
			}
			else if (meta.valid.reg) {
				var mreg = meta.reg
				output += "FMV.X.W " + ", " + temp + ", " + mreg + "\n"
			}
			else {
				output += "LW " + temp + ", " + meta.address + "(r0)\n"
			}
			var preg = ptr.register
			output += "SW " + temp + ", 0x" + Integer.toHexString(intValue) + "(" + preg + ")\n"
		}
		else {
			var mreg = meta.register
			var preg = ptr.register
			output += op + mreg + ", 0x" + Integer.toHexString(intValue) + "(" + preg + ")\n"
		}
	}
	
	// Export data structures that stored in the memory
	// taddr: current address to be written
	// faddr: the starting address that is free
	// raddr: the address of the to-be-exported data
	def void exportMetaData(String taddr, String faddr, String raddr, Type type) {

		// faddr = max(faddr, taddr + dataSize)
		var temp = getNewReg
		output += "ADDI " + temp + ", " + taddr + ", " + dataSize(type) + "\n"
  		output += "CMP " + faddr + ", " + temp + "\nNOP\n"
  		var flag = getNewReg
		output += "FBR LT, " + flag + "\n"
  		var k = arrayIndex++
  		output += "BEQ " + flag + ", r0, UPDATE_FADDR_" + k + "\n"
  		output += "ADDI " + faddr + ", " + temp + ", 0\n"
  		output += "UPDATE_FADDR_" + k + ":\n"

		if (type instanceof TupleType) {
			var ttype = (type as TupleType).type
			for (ele : ttype) {
	   			exportMetaData(taddr, faddr, raddr, ele)
				output += "ADDI " + taddr + ", " + taddr + ", " + dataSize(ele)
				output += "ADDI " + raddr + ", " + raddr + ", " + dataSize(ele)
			}
		}
		else if (type instanceof ArrayType) {
			output += "SUB " + temp + ", " + faddr + ", " + taddr + "\n"
			output += "SW " + temp + ", 0(" + taddr + ")\n"

	  		var rarray = getNewReg
	  		output += "LW " + rarray + ", 0(" + raddr + ")\n"
	  		var length = getNewReg
	  		output += "LW " + length + ", 0(" + rarray + ")\n"
			output += "SW " + length + ", 0(" + faddr + ")\n"

			// Update the pointers
			var tarray = getNewReg
			output += "ADDI " + tarray + ", " + faddr + ", " + INT_SIZE + "\n"
			output += "ADDI " + rarray + ", " + rarray + ", " + INT_SIZE + "\n"
			var ptype = (type as ArrayType).ptype
			var psize = dataSize(ptype)
			valueToReg(temp, psize)
			output += "MUL " + temp + ", " + temp + ", " + length + "\n"
			output += "ADD " + faddr + ", " + taddr + ", " + temp + "\n"
			
	  		output += "ADDI " + temp + ", r0, 0\n" // temp = 0
	  		output += "ARRAY_" + k  + ":\n"
	
	  		output += "CMP " + temp + ", " + length + "\nNOP\n"
			output += "FBR LT, " + flag + "\n"
	  		output += "BNE " + flag + ", r1, ARRAY_" + k + "_end\n"
	  
   			exportMetaData(tarray, faddr, rarray, ptype)
			output += "ADDI " + tarray + ", " + tarray + ", " + psize + "\n"
			output += "ADDI " + rarray + ", " + rarray + ", " + psize + "\n"
	
	  		// update index
	  		output += "ADDI " + temp + ", " + temp + ", 1\n"
	
	  		output += "BEQ r0, r0, ARRAY_"+ k  +"\n"  
	  		output += "ARRAY_"+ k +"_end:\n"
	  	}
	  	else {
  			output += loadOp(type) + temp + ", 0(" + raddr + ")\n"
  			output += storeOp(type) + temp + ", 0(" + taddr + ")\n"
	  	}
	}

	def dispatch MetaData compile(FunctionCall call, HashMap<String, MetaData> map) {
		compileFunctionCall(call.fun, call.pars, map, NodeModelUtils.getNode(call))
		return null
	}
	
	def MetaData compileFunctionCall(Variable v, EList<Expression> pars, HashMap<String, MetaData> map, ICompositeNode node) {
		var FunDeclaration fun
		if (v instanceof FunDeclaration) { // Normal function call
			fun = v
		}
		else {
			var uri = URI.createURI(map.get(v.name).reg)
			fun = v.eResource.resourceSet.getEObject(uri, false) as FunDeclaration
		}
		if (fun.o) {
			var index = funIndex++
			indexMap.put(fun, index)
	        var newMap = new HashMap<String, MetaData>
	        if (!(fun.type instanceof UnitType)) {
		        var ret = getScalaMeta(fun.type)
		        createMetaData(ret, fun.type, newMap)
		        newMap.put("return", ret)
		    }
		    
		    // Compile the parameters in the calling expression/statement
			for (var i=0; i<pars.size; i++) {
				var tmeta = fun.pars.get(i).compile(newMap)
				var ttype = fun.pars.get(i).type
				var smeta = pars.get(i).compile(map)
				assignMetaData(tmeta, smeta, ttype, node)
			}
			
			// Compile default parameters
			for (var i=pars.size; i<fun.pars.size; i++) {
				var tmeta = fun.pars.get(i).compile(newMap)
				var ttype = fun.pars.get(i).type
				var smeta = fun.pars.get(i).exp.compile(map)
				assignMetaData(tmeta, smeta, ttype, node)
			}
			
			// Execute the called operation
			fun.block?.compile(newMap)
			output += "function_" + index + "_end:\n\n"
	        return newMap.get("return")
		}
		else if (fun.f){
		
		}
		else if (fun.p) {
			var temporary = fetchConfig(fun, fun.name, "type")
			if (temporary.equals("init")) {
				output += "QWAIT " + fetchConfig(fun, fun.name, "duration") + '\n'
			}
			else if (temporary.equals("meas")) {
				var reg = pars.get(0).compile(map).reg
				output += fetchConfig(fun, fun.name, "eqasm") + " " + reg + '\n'
				output += "QWAIT " + fetchConfig(fun, fun.name, "duration") + "\n"	
				var rtemp = getNewReg
				output += "FMR " + rtemp + ", " + reg.replace('s', 'q') + '\n'
				var meta = new MetaData(rtemp)
				meta.valid.setOnlyReg
				meta.type = QuingoFactory::eINSTANCE.createBoolType
				return meta	
			}
			else if (temporary.equals("single-qubit")) {
				output += duration + fetchConfig(fun, fun.name, "eqasm")
				output += " " + pars.get(0).compile(map).reg + '\n'
				duration = fetchConfig(fun, fun.name, "duration") + ", "
			}
			else if (temporary.equals("single-qubit-param")) {
				output += duration + fetchConfig(fun, fun.name, "eqasm")
				var pmeta = pars.get(1).compile(map)
				if (!pmeta.valid.constant) {
					throw new IOException("[_compileFunctionCall] only constant double numbers are supported now!"
						+ " Check line " + node.startLine + "\n"
					)
				}
				var param = pmeta.value as Float
				if (param < 0) {
					output += 'm'
					param = -param
				}
				output += param.toString.replace('.', '_')
				output += " " + pars.get(0).compile(map).reg + '\n'
				duration = fetchConfig(fun, fun.name, "duration") + ", "
			}
			else if (temporary.equals("two-qubit")) {
				var q0 = pars.get(0).compile(map).reg.substring(1)
				var q1 = pars.get(1).compile(map).reg.substring(1)
				output += "SMIT t0, {(" + q0 + "," + q1 + ")}\n"
				output += duration + fetchConfig(fun, fun.name, "eqasm") + " t0\n"
				duration = fetchConfig(fun, fun.name, "duration") + ", "
			}
			else {
				output += "[_compileFunctionCall] temporary=" + temporary + "\n"
			}
			global += fetchConfig(fun, fun.name, "duration") as Integer
		}
		return null
	}

	def dispatch MetaData compile(ContinueStatement stat,HashMap<String, MetaData> map) {
		var container = stat.eContainer
		while (!(container instanceof WhileStatement || container instanceof ForStatement)) {
			container = container.eContainer
		}
		var continueindex = indexMap.get(container)
		if (continueindex.intValue > 0) {
			output += "BEQ r0, r0, labelwhile_" + continueindex + "\n"
		}
		return new MetaData
	}
	
	def dispatch MetaData compile(BreakStatement stat, HashMap<String, MetaData> map) {
		var container = stat.eContainer
		while (!(container instanceof WhileStatement || container instanceof ForStatement
		  || container instanceof SwitchStatement)) {
			container = container.eContainer
		}
		var breakindex = Math.abs(indexMap.get(container))
		output += "BEQ r0, r0, continue_" + breakindex + "\n"
		return new MetaData
	}
		
	def dispatch MetaData compile(WhileStatement stat, HashMap<String, MetaData> map) {
		var tempwhileindex = whileIndex++
		indexMap.put(stat, -tempwhileindex)
		var a = stat.expression.compile(map)
		var count = 0
		while (a.valid.constant) {
			if (a.value as Boolean) {
				stat.whilestat.compile(map)
				a = stat.expression.compile(map)
			}
			else {
				output += "continue_" + tempwhileindex + ":\n"
				return null
			}
			count++
			if (count >= Configuration.maxUnrolling) {
				output += "# Unrolling is up to " + count + " loops\n"
				a.valid.setOnlyReg
			}
		}

		//var set = collectVariable(stat.whilestat)
		var set = new HashSet<String>
		for (v: stat.eAllContents.toIterable.filter(ExpVariable)) {
			set.add(v.value.name)
		}
		for (variable: set) {
			variable.storeToMem(map)
		}
		output += "# storeToMem finishes\n"

		indexMap.put(stat, tempwhileindex)
		output += "labelwhile_"+ tempwhileindex + ":\n"
		a = stat.expression.compile(map)
		var reg = a.register
		output += "BNE " + reg + ", r1, continue_" + tempwhileindex + "\n"
		stat.whilestat.compile(map)
		for (variable: set) {
			variable.storeToMem(map)
		}
		output += "BEQ r0, r0, " + "labelwhile_"+ tempwhileindex + "\n"
		output += "continue_" + tempwhileindex + ":\n"

		return null
	}


	def dispatch MetaData compile(ForStatement stat, HashMap<String, MetaData> map) {
		stat.init.compile(map)
		
		var tempwhileindex = whileIndex++
		indexMap.put(stat, -tempwhileindex)
		var a = stat.cond.compile(map)
		var count = 0
		while (a.valid.constant) {
			if (a.value as Boolean) {
				stat.block.compile(map)
				stat.inc?.compile(map)
				a = stat.cond.compile(map)
			}
			else {
				output += "continue_" + tempwhileindex + ":\n"
				return null
			}
			count++
			if (count >= Configuration.maxUnrolling) {
				output += "# Unrolling is up to " + count + " loops\n"
				a.valid.setOnlyReg
			}
		}

		var set = collectVariable(stat.block)
		for (variable: set) {
			variable.storeToMem(map)
		}
		output += "# storeToMem finishes\n"
		indexMap.put(stat, tempwhileindex)
		output += "labelwhile_"+ tempwhileindex + ":\n"

		a = stat.cond.compile(map)
		var reg = a.register
		output += "BNE " + reg + ", r1, continue_" + tempwhileindex + "\n"
		stat.block.compile(map)
		stat.inc?.compile(map)

		for (variable: set) {
			variable.storeToMem(map)
		}
		output += "BEQ r0, r0, " + "labelwhile_"+ tempwhileindex + "\n"
		output += "continue_" + tempwhileindex + ":\n"
		return null
	}

	def dispatch MetaData compile(SwitchStatement stat, HashMap<String, MetaData> map) {
		if (stat.block === null) {
			return null
		}

	  	var switchExp = stat.expression.compile(map)
	  	if (switchExp.valid.constant) {
			var match = false
			var count = stat.block.size
			var i = 0
	  		for (i=0; i<count; i++) {
	  			var c = stat.block.get(i)
  				if (match && c.sblock!==null) {
  					c.sblock.compile(map)
  					return null
  				}
	  			var cexp = c.exp.compile(map)
	  			if (cexp.valid.constant) {
  					match = switchExp.value == cexp.value
	  			}
	  			else {
	  				i = count + 1 // break;
	  			}
	  		}
	  		if (i === count) { // all the cases are constant
	  			stat.def.sblock.compile(map)
	  			return null
	  		}
	  	}

		var index = switchIndex++
		indexMap.put(stat, index)
		var block = stat.block
		var length = block.length
		var num = newIntArrayOfSize(length + 1)
		num.set(length, -1)
		for (var i=length-1; i>=0; i--) {
			if (block.get(i).sblock === null) {
				num.set(i, num.get(i + 1))
			}
			else {
				num.set(i, i)
			}
		}
		
		map.storeToMem
	 	for (var i=0; i<block.length; i++) {
			var cas = block.get(i)
			if (num.get(i) !== -1) {
				var meta = cas.exp.compile(map)
				var sreg = switchExp.register
				var mreg = meta.register
				if (cas.sblock === null) {
					output += "BEQ " + sreg + ", " + mreg + ", switch_" + index + "_" + num.get(i) + "\n"
				}
				else {
					output += "BNE " + sreg + ", " + mreg + ", switch_" + index + "_" + i + "_end\n"
					output += "switch_" + index + "_" + i + ":\n"
					cas.sblock.compile(map)
					output += "switch_" + index + "_" + i + "_end:\n"
				}
			}
		}

		stat.def?.sblock?.compile(map) // null-safe calling

		output += "continue_" + index + ":\n"
		return null
	}

	def dispatch MetaData compile(IfStatement stat, HashMap<String, MetaData> map) {
		var condition = stat.expression.compile(map)
		if (condition.valid.constant) {
			if (condition.value as Boolean) {
				return stat.ifStat.compile(map)
			}
			else {
				return stat.elseStat?.compile(map)
			}
		}
		else {
			var set = collectVariable(stat.ifStat)
			for (variable: set) {
				variable.storeToMem(map)
			}
			var index = ifIndex++
			var creg = condition.register
			if (stat.elseStat === null) {
				output += "BNE " + creg + ", r1, if_" + index + "_end\n"
				stat.ifStat.compile(map)
				for (variable: set) {
					variable.storeToMem(map)
				}
				output += "if_" + index + "_end:\n"
			}
			else {
				output += "BNE " + creg + ", r1, ne_path_" + index + "\n"
				stat.ifStat.compile(map)
				for (variable: set) {
					variable.storeToMem(map)
				}
				output += "BEQ r0, r0, if_" + index + "_end\n"
				output += "ne_path_" + index + ":\n"
				var elseSet = collectVariable(stat.elseStat)
				for (variable: elseSet) {
					variable.storeToMem(map)
				}
				stat.elseStat.compile(map)
				for (variable: elseSet) {
					variable.storeToMem(map)
				}
				output += "if_" + index + "_end:\n"
			}
		}
		return null
	}
	
	def dispatch MetaData compile(Assignment assignment, HashMap<String, MetaData> map) {
		var rmeta = assignment.value.compile(map)
		left = true
		var leftExp = assignment.left as Expression
		var lmeta = leftExp.compile(map)
		left = false
		assignMetaData(lmeta, rmeta, xsemantics.exptype(leftExp).value, NodeModelUtils.getNode(assignment))
		return null
	}
	
	def dispatch MetaData compile(OpAssignment assignment, HashMap<String, MetaData> map) {
		var rmeta = assignment.right.compile(map)
		left = true
		var leftExp = assignment.left as Expression
		var lmeta = leftExp.compile(map)
		left = false
		var meta = compileOperator(lmeta, rmeta, assignment.op.replaceFirst("=", ""))
		assignMetaData(lmeta, meta, xsemantics.exptype(leftExp).value, NodeModelUtils.getNode(assignment))
		return null
	}
	
	def dispatch MetaData compile(UsingStatement stat, HashMap<String, MetaData> map) {
		var qvar = stat.qvar
		var type = stat.type
		var qnum = 0
		if (qvar.length > 1) {
			var ttype = (type as TupleType).type
			for (var i=0; i<qvar.length; i++) {
				var meta = allocateQubit(qvar.get(i).name, ttype.get(i), map)
				if (meta.link === null) {
					qnum += 1
				}
				else {
					qnum += meta.value as Integer
				}
			}
		}
		else {
			var meta = allocateQubit(qvar.get(0).name, type, map)
			if (meta.link === null) {
				qnum += 1
			}
			else {
				qnum += meta.value as Integer
			}
		}
		stat.block.compile(map)
		sIndex -= qnum // deallocate qubits
		return null
	}
	
	def MetaData allocateQubit(String name, Type type, HashMap<String, MetaData> map) {
		var meta = new MetaData
		if (type instanceof QubitType) {
			meta.reg = "s" + sIndex
			output += "SMIS " + meta.reg + ", {" + sIndex++ + "}\n"
		}
		else {
			var atype = type as ArrayType
			if (atype.length === null) {
				meta.value = 0
			}
			else {
				var lengMeta = atype.length.compile(map)
				if (!lengMeta.valid.constant) {
					writeFile
					throw new IOException("[allocateQubit] The length of qubit array must be constant!\n")
				}
				meta.value = lengMeta.value
			}
			meta.valid.constant = true
			meta.link = new ArrayList<MetaData>
			for (var i=0; i<meta.value as Integer; i++) {
				var child = new MetaData
				child.reg = "s" + sIndex
				output += "SMIS " + child.reg + ", {" + sIndex++ + "}\n"
				meta.link.add(child)
			}
		}
		meta.type = QuingoFactory::eINSTANCE.createQubitType
		map.put(name, meta)
		return meta
	}
		
	def dispatch MetaData compile(EmptyStatement stat, HashMap<String, MetaData> map) {
		return null
	}
	
	def dispatch MetaData compile(TimerDeclaration timer, HashMap<String, MetaData> map) {
		timerMap.put(timer, global)
		return null
	}
	
	def dispatch MetaData compile(TimingConstraint stat, HashMap<String, MetaData> map) {
		var timer = timerMap.get(stat.timer)
		var meta = stat.value.compile(map)
		var delay = timer + meta.value as Integer - global
		output += "QWAIT " + delay + "\n"
		global += delay
		return null
	}
	
	def dispatch MetaData compile(ExpFunctionCall exp, HashMap<String, MetaData> map) {
		return compileFunctionCall(exp.fun, exp.pars, map, NodeModelUtils.getNode(exp))
	}
	
	def dispatch MetaData compile(Or exp, HashMap<String, MetaData> map) {
		var lmeta = exp.left.compile(map)
		var rmeta = exp.right.compile(map)
		if (lmeta.valid.constant && rmeta.valid.constant) {
			return new MetaData(lmeta.value as Boolean || rmeta.value as Boolean)
		}
		var lreg = lmeta.register
		var rreg = rmeta.register
		var meta = getScalaMeta(QuingoFactory.eINSTANCE.createBoolType)
		output += "OR " + meta.register + ", " + lreg + ", " + rreg + "\n"
		return meta	
	}
	
	def dispatch MetaData compile(And exp, HashMap<String, MetaData> map) {
		var lmeta = exp.left.compile(map)
		var rmeta = exp.right.compile(map)
		if (lmeta.valid.constant && rmeta.valid.constant) {
			return new MetaData(lmeta.value as Boolean && rmeta.value as Boolean)
		}
		var lreg = lmeta.register
		var rreg = rmeta.register
		var meta = getScalaMeta(QuingoFactory.eINSTANCE.createBoolType)
		output += "AND " + meta.register + ", " + lreg + ", " + rreg + "\n"
		return meta
	}
	
	def dispatch MetaData compile(Equal exp, HashMap<String, MetaData> map) {
		var lmeta = exp.left.compile(map)
		var rmeta = exp.right.compile(map)
		if (lmeta.valid.constant && rmeta.valid.constant) {
			if (exp.op == "==") {
				return new MetaData(lmeta.value == rmeta.value)
			}
			else {
				return new MetaData(lmeta.value != rmeta.value)
			}
		}
		var lreg = lmeta.register
		var rreg = rmeta.register
		var meta = getScalaMeta(QuingoFactory.eINSTANCE.createBoolType)
		var reg = meta.register
		if (lmeta.type instanceof DoubleType) {
			output += "FEQ.S " + reg + ", " + lreg + ", " + rreg + "\n"
			if (exp.op.equals("!=")) {
				output += "SUB " + reg + ", r1, " + reg + "\n"
			}
		}
		else {
			output += "CMP " + lreg + ", " + rreg + "\nNOP\n"
			if(exp.op.equals("==")) {
				output += "FBR EQ, " + reg + "\n"
			}
			else {
				output += "FBR NE, " + reg + "\n"
			}
		}
		return meta	
	}	

	def dispatch MetaData compile(NEqual exp, HashMap<String, MetaData> map) {
		var lmeta = exp.left.compile(map)
		var rmeta = exp.right.compile(map)
		if (lmeta.valid.constant && rmeta.valid.constant) {
			if (lmeta.type instanceof DoubleType) {
				var lvalue = lmeta.value as Float
				var rvalue = rmeta.value as Float
				return switch (exp.op) {
					case "<":
						new MetaData(lvalue < rvalue)
					case "<=":
						new MetaData(lvalue <= rvalue)
					case ">=":
						new MetaData(lvalue >= rvalue)
					case ">":
						new MetaData(lvalue > rvalue)
				}
			}
			else {
				var lvalue = lmeta.value as Integer
				var rvalue = rmeta.value as Integer
				return switch (exp.op) {
					case "<":
						new MetaData(lvalue < rvalue)
					case "<=":
						new MetaData(lvalue <= rvalue)
					case ">=":
						new MetaData(lvalue >= rvalue)
					case ">":
						new MetaData(lvalue > rvalue)
				}
			}
		}

		var lreg = lmeta.register
		var rreg = rmeta.register
		var meta = getScalaMeta(QuingoFactory.eINSTANCE.createBoolType)
		var reg = meta.register
		if (lmeta.type instanceof DoubleType) {
			if (exp.op.equals("<")) {
				output += "FLT.S " + reg + ", " + lreg + ", " + rreg + "\n"
			}
			else if (exp.op.equals("<=")) {
				output += "FLE.S " + reg + ", " + lreg + ", " + rreg + "\n"
			}
			else if(exp.op.equals(">=")) {
				output += "FLT.S " + reg + ", " + lreg + ", " + rreg + "\n"
				output += "SUB " + reg + ", r1, " + reg + "\n"
			}
			else if (exp.op.equals(">")) {
				output += "FLE.S " + reg + ", " + lreg + ", " + rreg + "\n"
				output += "SUB " + reg + ", r1, " + reg + "\n"
			}
		}
		else {
			output += "CMP " + lreg + ", " + rreg + "\nNOP\n"
			if (exp.op.equals("<")) {
				output += "FBR LT, " + reg + "\n"
			}
			else if (exp.op.equals("<=")) {
				output += "FBR LE, " + reg + "\n"
			}
			else if(exp.op.equals(">=")) {
				output += "FBR GE, " + reg + "\n"
			}
			else if (exp.op.equals(">")) {
				output += "FBR GT, " + reg + "\n"
			}
		}
		return meta
	}
	
	def MetaData compileOperator(MetaData lmeta, MetaData rmeta, String op) {
		if (lmeta.valid.constant && rmeta.valid.constant) {
			if (lmeta.type instanceof IntType) {
				var lvalue = lmeta.value as Integer
				var rvalue = rmeta.value as Integer
				switch (op) {
				case "+":
					return new MetaData(lvalue + rvalue)
				case "-":
	    			return new MetaData(lvalue - rvalue)
	   			case "*":
			  	  	return new MetaData(lvalue * rvalue)
	   			case "/":
					return new MetaData(lvalue / rvalue)
	   			case "%":
					return new MetaData(lvalue % rvalue)
				}
			}
			else {
				var lvalue = lmeta.value as Float
				var rvalue = rmeta.value as Float
				switch (op) {
				case "+":
					return new MetaData(lvalue + rvalue)
				case "-":
	    			return new MetaData(lvalue - rvalue)
	   			case "*":
			  	  	return new MetaData(lvalue * rvalue)
	   			case "/":
					return new MetaData(lvalue / rvalue)
				}
			}
		}
		var lreg = lmeta.register
		var rreg = rmeta.register
		var meta = getScalaMeta(lmeta.type)
		var reg = meta.register
		var String inst
		inst = switch (op) {
			case "+": "ADD"
			case "-": "SUB"
	 		case "*": "MUL"
	 		case "/": "DIV"
	 		case "%": "REM"
		}
		if (lmeta.type instanceof DoubleType) {
			inst = "F" + inst + ".S"
		}
		output += inst + " " + reg + ", " + lreg + ", " + rreg + "\n"
		return meta
	}
	
	def dispatch MetaData compile(Add exp, HashMap<String, MetaData> map) {
		var lmeta = exp.left.compile(map)
		var rmeta = exp.right.compile(map)
		return compileOperator(lmeta, rmeta, exp.op)
	}
	
	def dispatch MetaData compile(Mult exp, HashMap<String, MetaData> map) {
		var lmeta = exp.left.compile(map)
		var rmeta = exp.right.compile(map)
		return compileOperator(lmeta, rmeta, exp.op)
	}

	def dispatch MetaData compile(Unary exp, HashMap<String, MetaData> map) {
		var fmeta = exp.final.compile(map)
		if (exp.op == "+") {
			return fmeta
		}	

		if (fmeta.valid.constant) {
			if (exp.op == "-") {
				if (fmeta.value instanceof Integer) {
					return new MetaData(-(fmeta.value as Integer))
				}
				else if (fmeta.value instanceof Float) {
					return new MetaData(-(fmeta.value as Float))
				}
			}	
			else if (exp.op == "!") {
				return new MetaData(!(fmeta.value as Boolean))
			}
		}
		fmeta.register
		var meta = getScalaMeta(fmeta.type)
		var reg = meta.register
		if (exp.op == "-") {
			if (fmeta.type instanceof DoubleType) {
				output += "FNEG.S " + reg + ", " + fmeta.reg + "\n"
			}
			else {
				output += "SUB " + reg + ", r0, " + fmeta.reg + "\n"
			}
		}
		else if (exp.op == "!") {
			output += "SUB " + reg + ", r1, " + fmeta.reg + "\n"
		}
		return meta
	}

	def dispatch MetaData compile(ExpVariable exp, HashMap<String, MetaData> map) {
		var value = (exp as ExpVariable).value
		if (value instanceof FunDeclaration) {
			return new MetaData(EcoreUtil.getURI(exp.value).toString)
		}
		else {
			var meta = map.get(exp.value.name)
			if (!left && !meta.valid.atLeastOne && !(meta.type instanceof QubitType)) {
				throw new IOException("The value of variable " + value.name + " in line "
					+ NodeModelUtils.getNode(exp).getStartLine + " of "
					+ exp.eResource.URI.lastSegment + " is undefined!")
			}
			return meta
		}
	}
	
	def void assignMetaData(MetaData target, MetaData right, Type type, ICompositeNode node) {
		if (type instanceof TupleType) {
			var ttype = (type as TupleType).type
			var benull = target.link === null
			if (benull) {
				target.link = new ArrayList<MetaData>
			}
			var addr = target.addr
			for (var i=0; i<ttype.length; i++) {
				var cright = right.link.get(i)
				var ctype = ttype.get(i)

				var MetaData ctarget
				if (benull) {
					ctarget = getScalaMeta(ctype)
					ctarget.address = addr
					addr += ctype.dataSize
					target.link.add(ctarget)
				}
				else {
					ctarget = target.link.get(i)
				}
				assignMetaData(ctarget, cright, ctype, node)
			}
			target.valid.setOnlyConstant
		}
		else if (type instanceof ArrayType) {
			var ptype = (type as ArrayType).ptype
			if (target.valid.constant && right.valid.constant) {
				var rvalue = (right.value as Integer).intValue
				if ((target.link === null) || (target.value as Integer) < rvalue) {
					var reg = target.register
					valueToReg(reg, memoryAddr)
					//target.valid.setConAndReg
					target.value = rvalue
						
					// Allocate memory for the array
					var addr = memoryAddr + INT_SIZE
					var size = dataSize(ptype)
					memoryAddr = addr + rvalue * size
					
					// Create array members
					target.link = new ArrayList<MetaData>
					for (rchild : right.link) {
						var tchild = getScalaMeta(type.ptype)
						tchild.address = addr
						addr += size
						assignMetaData(tchild, rchild, ptype, node)
						target.link.add(tchild)
					}
				}
				else {
					for (var i=0; i<rvalue; i++) {
						assignMetaData(target.link.get(i), right.link.get(i), ptype, node)
					}
					var num = (target.value as Integer) - rvalue
					for (var i=0; i<num; i++) {
						target.link.remove(rvalue)
					}
					target.value = right.value
				}
				target.valid.constant = true
			}
			else {
				for (m : regToMeta.values) {
					m.storeToMem
				}
				target.storeToMem
				right.storeToMem
				var taddr = getScalaMeta(target.type)
				var treg = taddr.register
				valueToReg(treg, target.address)
				var raddr = getScalaMeta(right.type)
				var rreg = raddr.register
				valueToReg(rreg, right.address)
				assignDataInMem(taddr, raddr)
				target.valid.setOnlyMem
			}
		}
		else if (type instanceof QubitType || type instanceof FunctionType) {
			target.reg = right.reg
		}
		else { // normal assignment
			if (target.type instanceof PointerType) {
				var rreg = right.register
				var treg = target.register
				output += storeOp(right.type) + rreg + ", " + hex(target.value as Integer) + "(" + treg + ")\n"
				target.valid.setOnlyReg
				return
			}
			if (right.valid.constant) {
				target.valid.setOnlyConstant
				target.value = right.value
				target.type = xsemantics.copytype(right.type).value
				return
			}
			else if (right.valid.mem) {
				right.register
			}
			
			if (right.valid.reg) {
				var treg = target.register
				var rreg = right.register
				if (right.type instanceof DoubleType) {
					output += "FADD " + treg + ", " + rreg + ", f0\n"
				}
				else {
					output += "ADD " + treg + ", " + rreg + ", r0\n"
				}
				target.type = xsemantics.copytype(right.type).value
				target.valid.setOnlyReg
			}
			else { // right.valid === Position::NONE
				writeFile
				throw new IOException("[assignMetaData] undefined source value in line " + node.startLine + "!\n")
			}
		}
	}
	
	def void assignDataInMem(MetaData taddrMeta, MetaData raddrMeta) {
		var taddr = taddrMeta.register
		var raddr = raddrMeta.register

		var type = taddrMeta.type
		if (type instanceof ArrayType) {
			var treg = getNewReg
	  		output += "LW " + treg + ", 0(" + taddr + ")\n"
	  		var rreg = getNewReg
	  		output += "LW " + rreg + ", 0(" + raddr + ")\n"

			// Compare the length
			var rlengthMeta = getScalaMeta(QuingoFactory.eINSTANCE.createIntType)
	  		var rlength = rlengthMeta.register
	  		output += "LW " + rlength + ", 0(" + rreg + ")\n"
			var tlengthMeta = getScalaMeta(QuingoFactory.eINSTANCE.createIntType)
	  		var tlength = tlengthMeta.register
	  		output += "LW " + tlength + ", 0(" + treg + ")\n"
	  		output += "CMP " + rlength + ", " + tlength + "\n"
	  		output += "NOP\n"
	  		var k = arrayIndex++
	  		output += "FBR LE, " + tlength + "\n"
			output += "BNE " + tlength + ", r0, ARRAY_ALLOC_" + k + "_END\n"

			// Allocate memory for the target array
			output += "ADDI " + treg + ", r2, 0\n"
			output += "SW r2, 0(" + taddr + ")\n"
			updateFreeAddr(type.ptype, rlengthMeta)
	  		output += "ARRAY_ALLOC_" + k  + "_END:\n"
	
	  		// Copy the length
	  		output += "SW " + rlength + ", 0(" + treg+ ")\n"

	  		var rLowaddrMeta = getScalaMeta(type.ptype)
	  		var rLowaddr = rLowaddrMeta.register
	  		output += "ADDI " + rLowaddr + ", " + rreg + ", " + INT_SIZE + "\n"
	  		var tLowAddrMeta = getScalaMeta(type.ptype)
	  		var tLowAddr = tLowAddrMeta.register
	  		output += "ADDI " + tLowAddr + ", " + treg + ", " + INT_SIZE + "\n"
	
	  		var rindexMeta = getScalaMeta(QuingoFactory.eINSTANCE.createIntType)
	  		var rindex = rindexMeta.register
	  		output += "ADDI " + rindex + ", r0, 0\n" // rindex = 0

			// while (rindex < rlength)
	  		output += "ARRAY_" + k + ":\n"
			output += "CMP " + rindex + ", " + rlength + "\nNOP\n"
	  		var flag = getNewReg
			output += "FBR LT, " + flag + "\n"
	  		output += "BNE " + flag + ", r1, ARRAY_" + k + "_end\n"
	  		
	  		// Recursively copy
	  		assignDataInMem(tLowAddrMeta, rLowaddrMeta)

	  		// Update index
	  		rindex = rindexMeta.register
	  		output += "ADDI " + rindex + ", " + rindex + ", " + 1 + "\n"	
	  		output += "BEQ r0, r0, ARRAY_" + k + "\n"
	  		output += "ARRAY_" + k + "_end:\n"
		}
	  	else {
	  		var flag = getNewReg(type)
  			output += loadOp(type) + flag + ", 0(" + raddr + ")\n"
  			output += storeOp(type) + flag + ", 0(" + taddr + ")\n"
	  	}
	  	
	  	// Advance the pointers
  		var size = dataSize(type)
  		output += "ADDI " + raddr + ", " + raddr + ", " + size + "\n"
  		output += "ADDI " + taddr + ", " + taddr + ", " + size + "\n"
	}
	
	def void assignDataInMem(Type type, String rreg, String treg, String addr) {
		if (type instanceof TupleType) {
			var ttype = (type as TupleType).type
			for (ele : ttype) {
	   			assignDataInMem(ele, rreg, treg, addr)
			}
		}
		else if (type instanceof ArrayType) {
	  		var rlength = getNewReg
	  		output += "LW " + rlength + ", 0(" + rreg + ")\n"
	  		var tlength = getNewReg
	  		output += "LW " + tlength + ", 0(" + treg + ")\n"
	  		output += "CMP " + rlength + ", " + tlength + "\n"
	  		output += "NOP\n"
	  		var k = arrayIndex++
	  		output += "FBR LE, " + tlength + "\n"
			output += "BNE " + tlength + ", r0, ARRAY_ALLOC_" + k + "\n"
	  		output += "ADDI " + treg + ", r2, 0\n"
	  		output += "SW " + treg + ", 0(" + addr + ")\n"
	  		output += "ADDI r2, r2, " + INT_SIZE + "\n"
			var ptype = (type as ArrayType).ptype
			var size = dataSize(ptype)
	  		var rindex = getNewReg
	  		var taddr = getNewReg
	  		var flag = getNewReg
			if (ptype instanceof ArrayType) {
				valueToReg(tlength, Configuration.staticAddr)
		  		output += "ADDI " + rindex + ", r0, 0\n" // rindex = 0
				output += "ADDI " + taddr + ", " + treg + "," + INT_SIZE + "\n"
		  		output += "HIGHER_ARRAY_ALLOC_" + k + ":\n"
		  		output += "CMP " + rindex + ", " + rlength + "\n"
		  		output += "NOP\n"
				output += "FBR GE, " + flag + "\n"
				output += "BNE " + flag + ", r0, HIGHER_ARRAY_ALLOC_" + k + "END\n"
				output += "SW " + tlength + ", 0(" + taddr + ")\n"
		  		output += "ADDI " + rindex + ", " + rindex + ", " + 1 + "\n"
		  		output += "ADDI " + taddr + ", " + taddr + ", " + size + "\n"
		  		output += "BEQ r0, r0, HIGHER_ARRAY_ALLOC_" + k + ":\n"
		  		output += "HIGHER_ARRAY_ALLOC_" + k + "_END:\n"
			}
			else {
				valueToReg(tlength, size)
				output += "MUL " + tlength + ", " + tlength + ", " + rlength + "\n"
				output += "ADD r2, r2, " + tlength + "\n"
			}
	  		output += "ARRAY_ALLOC_" + k + ":\n"
	  		
	  		output += "SW " + rlength + ", 0(" + treg+ ")\n"
	
	  		var raddr = getNewReg
	  		output += "ADDI " + raddr + ", " + rreg + ", " + INT_SIZE + "\n"
	  		output += "ADDI " + taddr + ", " + treg + ", " + INT_SIZE + "\n"
	
	  		output += "ADDI " + rindex + ", r0, 0\n" // rindex = 0
	  		output += "ARRAY_" + k  + ":\n"
	
			output += "CMP " + rindex + ", " + rlength + "\nNOP\n"
			output += "FBR LE, " + flag + "\n"
	  		output += "BNE " + flag + ", r1, ARRAY_" + k + "_end\n"
	  
			if (ptype instanceof ArrayType) {
				var rlow = getNewReg
				output += "LW " + rlow + ", 0(" + raddr + ")\n"
				var tlow = getNewReg
				output += "LW " + tlow + ", 0(" + taddr + ")\n"
	   			assignDataInMem(ptype, rlow, tlow, taddr)
			}
			else {
	   			assignDataInMem(ptype, raddr, taddr, addr)
			}
	
	  		// update index
	  		output += "ADDI " + rindex + ", " + rindex + ", " + 1 + "\n"
	
	  		output += "BEQ r0, r0, ARRAY_" + k + "\n"  
	  		output += "ARRAY_" + k + "_end:\n"
	  	}
	  	else {
	  		var flag = getNewReg(type)
  			output += loadOp(type) + flag + ", 0(" + rreg + ")\n"
  			output += storeOp(type) + flag + ", 0(" + treg + ")\n"
	  	}

  		var size = dataSize(type)
  		output += "ADDI " + rreg + ", " + rreg + ", " + size + "\n"
  		output += "ADDI " + treg + ", " + treg + ", " + size + "\n"
	}
	
	def dispatch MetaData compile(BooleanLiteral exp, HashMap<String, MetaData> map) {
		return new MetaData(exp.isTrue)
	}
	
	def dispatch MetaData compile(IntLiteral exp, HashMap<String, MetaData> map) {
		return new MetaData(exp.value)
	}
	
	def dispatch MetaData compile(DoubleLiteral exp, HashMap<String, MetaData> map) {
		return new MetaData(exp.value)
	}
	
	def dispatch MetaData compile(ArrayAccess exp, HashMap<String, MetaData> map) {
     	// get the base address
     	var base = exp.array.compile(map)
		var dim = exp.dim.compile(map)
		
		if (base.valid.constant) {
			if (dim.valid.constant) {
				var dimValue = dim.value as Integer
				var baseValue = base.value as Integer
				if (dimValue >= baseValue) {
					var node = NodeModelUtils.getNode(exp)
					throw new IndexOutOfBoundsException(node.getText + " at line " + node.getStartLine
						+ " accesses index " + dimValue + " in an array of size " + baseValue
					)
				}
				return base.link.get(dimValue)
			}
			else {
				base.storeToMem
			}
		}
     	
		var type = (xsemantics.exptype(exp.array).value as ArrayType).ptype
		var ptr = left && !(type instanceof ArrayType)
		var size = dataSize(type)
		
		// calculate shift
		var String rtemp
	    rtemp = getNewReg   

		var shift = 0
		var rmeta = new MetaData(rtemp)
		rmeta.valid.setOnlyReg
		var op = loadOp(type)

		if (dim.valid.constant) {
			shift = size * (dim.value as Integer).intValue + INT_SIZE
			if (ptr) {
				rmeta.reg = base.register
				rmeta.value = shift
				rmeta.type = new PointerType
			}
			else {
				var breg = base.register
	     		output += op + rtemp + ", " + shift + "(" + breg  + ")\n" // actual fetch
	     		rmeta.type = xsemantics.copytype(type).value
	     	}
		}
		else {
			valueToReg(rtemp, size) // rtemp = size
			var dreg = dim.register
	     	output += "MUL " + rtemp + ", " + rtemp + ", " + dreg + "\n" // rtemp *= dim
			output += "ADDI " + rtemp + ", " + rtemp + ", " + INT_SIZE + "\n" // rtemp += 4 (considering the element that stores the length)
			var breg = base.register
	     	output += "ADD " + rtemp + ", " + breg + ", "+ rtemp + "\n" // rtemp += base
			if (ptr) {
				rmeta.reg = rtemp
				rmeta.value = 0
				rmeta.type = new PointerType
			}
			else {
		     	output += op + rtemp + ", 0("  + rtemp  + ")\n" // final fetch
	     		rmeta.type = xsemantics.copytype(type).value
		    }
		}
     	
		return rmeta
	}
	
	def dispatch MetaData compile(ExpLength exp, HashMap<String, MetaData> map) {
  		var addr = (exp as ExpLength).left.compile(map)
  		if (addr.valid.constant) {
  			return new MetaData(addr.value as Integer)
  		}
  		else {
	     	var meta = new MetaData
  			var reg = meta.register
	  		output += "LW " + reg + ", 0("  + addr.reg  + ")\n"
	  		meta.valid.setOnlyReg
	  		return meta
	  	}
  	}
   	
   	def dispatch MetaData compile(ExpTuple exp, HashMap<String, MetaData> map) {
   		var length = exp.texp.length
   		if (length === 1) {
   			return exp.texp.get(0).compile(map)
   		}
   		var meta = new MetaData
   		meta.value = length
   		meta.link = new ArrayList<MetaData>
   		meta.type = QuingoFactory.eINSTANCE.createTupleType
	   	for (var i=0; i<length; i++) {
	   		meta.link.add(exp.texp.get(i).compile(map))
	   	}
	   	return meta
   	}
   	
   	def dispatch MetaData compile(ExpArray exp, HashMap<String, MetaData> map) {
		var length = exp.exp.length
		var link = new ArrayList<MetaData>
		for (e: exp.exp) {
			link.add(e.compile(map))
		}

   		var meta = new MetaData
   		meta.type = QuingoFactory.eINSTANCE.createArrayType => [
   			ptype = xsemantics.exptype(exp.exp.get(0)).value
   		]
		meta.value = length
		meta.valid.setOnlyConstant
		meta.link = link
		return meta	
	}
	
	def dispatch MetaData compile(ToInt exp, HashMap<String, MetaData> map) {
		var fmeta = exp.value.compile(map)
		if (fmeta.type instanceof IntType) {
			return fmeta
		}
		if (fmeta.valid.constant) {
			return new MetaData((fmeta.value as Float).intValue)
		}
		var meta = getScalaMeta(QuingoFactory.eINSTANCE.createIntType)
		var freg = fmeta.register
		var reg = meta.register
		output += "FCVT.W.S " + reg + ", " + freg + "\n"
		return meta
	}
	
	def dispatch MetaData compile(ToDouble exp, HashMap<String, MetaData> map) {
		var imeta = exp.value.compile(map)
		if (imeta.type instanceof DoubleType) {
			return imeta
		}
		if (imeta.valid.constant) {
			return new MetaData((imeta.value as Integer).floatValue)
		}
		var meta = getScalaMeta(QuingoFactory.eINSTANCE.createDoubleType)
		var ireg = imeta.register
		var reg = meta.register
		output += "FCVT.S.W " + reg + ", " + ireg + "\n"
		return meta
	}
	
	def collectVariable(Statement stat) {
		var ret = new HashSet<String>
		for (r : stat.eAllContents.toIterable.filter(Assignment)) {
			for (v : r.eAllContents.toIterable.filter(ExpVariable)) {
				ret.add(v.value.name)
			}
		}
		for (r : stat.eAllContents.toIterable.filter(OpAssignment)) {
			for (v : r.eAllContents.toIterable.filter(ExpVariable)) {
				ret.add(v.value.name)
			}
		}
		return ret
	}
		
	def storeToMem(HashMap<String, MetaData> map) {
		for (meta: map.values) {
			if (!(meta.type instanceof QubitType) && meta.valid.atLeastOne) {
				meta.storeToMem
			}
		}
	}
	
	def storeToMem(String str, HashMap<String, MetaData> map) {
		map.get(str).storeToMem
	}
	
	def void storeToMem(MetaData meta) {
		var link = meta.link
		var valid = meta.valid

		if (meta.type instanceof TupleType) {
			for (child : link) {
				child.storeToMem
			}
			return
		}
		else if (meta.type instanceof QubitType) {
			return
		}

		if (meta.valid.mem) {
			valid.setOnlyMem
			return
		}
		
		var addr = meta.addr
		var op = storeOp(meta.type)
		if (valid.constant) {
			if (meta.type instanceof ArrayType) {
				var rlength = newReg
				valueToReg(rlength, meta.value as Integer)
				var reg = meta.register
				output += "SW " + rlength + ", 0(" + reg + ")\n"
				output += "SW " + reg + ", " + hex(addr) + "(r0)\n"
				for (child : link) {
					child.storeToMem
				}
				meta.link = null
				meta.reg = ""
			}
			else if (meta.type instanceof BoolType) {
				var src = meta.value as Boolean? "r1": "r0"
				output += op + src + ", 0x" + Integer.toHexString(addr) + "(r0)\n"
			}
			else {
				var rreg = meta.getRegister
				output += op + rreg + ", 0x" + Integer.toHexString(addr) + "(r0)\n"
			}
		}
		else if (valid.reg) {
			var reg = meta.register
			output += op + reg + ", 0x" + Integer.toHexString(addr) + "(r0)\n"
		}
		valid.setOnlyMem
	}
	
	def valueToReg(String reg, int value) {
		if (value < 0x1000 && value > -0x1000) {
			output += "ADDI " + reg + ", r0, " + value + "\n"
		}
		else {
			output += "LDI " + reg + ", " + hex(value.bitwiseAnd(0xFFFFF)) + "\n"
			output += "LDUI " + reg + ", " + reg + ", " + hex(value >>> 17) + "\n"
		}
	}
	
	def String getRegister(MetaData meta) {
		var valid = meta.valid
		if (valid.reg) {
			return meta.reg
		}
		if (meta.reg.equals("")) {
			meta.reg = getNewReg(meta.type)
		}
		if (valid.constant) {
			if (meta.type instanceof BoolType) {
				var src = (meta.value as Boolean)? "r1": "r0"
				output += "ADD " + meta.reg + ", " + src + ", r0\n"
			}
			else if (meta.type instanceof DoubleType) {
				var temp = getNewReg
				valueToReg(temp, Float.floatToIntBits(meta.value as Float))
				output += "FMV.W.X " + meta.reg + ", " + temp + "\n"
			}
			else if (meta.type instanceof ArrayType) {
				output += "LW " + meta.reg + ", 0x" + Integer.toHexString(meta.address) + "(r0)\n"
			}
			else {
				valueToReg(meta.reg, meta.value as Integer)
			}
		}
		else if (valid.mem) {
			output += loadOp(meta.type) + meta.reg + ", " + hex(meta.address) + "(r0)\n"
		}
		valid.reg = true
		regToMeta.put(meta.reg, meta)
		return meta.reg
	}

	def int getAddr(MetaData meta) {
		if (meta.address === 0) {
			meta.address = allocateAddr(meta.type)
		}
		return meta.address
	}

	def int dataSize(Type type) {
		if (type instanceof IntType) {
			return INT_SIZE
		}
		else if (type instanceof BoolType) {
			return BOOL_SIZE
		}
		else if (type instanceof ArrayType) {
			return POINTER_SIZE 
		}
		else if (type instanceof PointerType) {
			return POINTER_SIZE 
		}
		else if (type instanceof DoubleType) {
			return DOUBLE_SIZE 
		}
		else if (type instanceof TupleType) {
			var sum = 0
			for (ttype: type.type) {
				sum += dataSize(ttype)
			}
			return sum
		}
		return 0
	}

	def String getNewReg() {
		getNewReg(QuingoFactory::eINSTANCE.createIntType)
	}
	
	def String getNewReg(Type type) {
		var String reg
		if (type instanceof DoubleType) {
			if (fIndex > 31) {
				fIndex = 1
			}
			reg = "f" + fIndex++
		}
		else {
			if (iIndex > 31) {
				iIndex = 3
			}
			reg = "r" + iIndex++
		}

		var meta = regToMeta.get(reg)
		if (meta !== null) {
			var valid = meta.valid
			if (valid.onlyReg) { //store reg to memory
				if (meta.address === 0) {
					meta.address = allocateAddr(meta.type)
				}
				output += storeOp(meta.type) + meta.reg  + ", " + hex(meta.address) + "(r0)\n"
				valid.setOnlyMem
			}
			meta.reg = ""
			valid.reg = false
		}

		return reg
	}
	
	def storeOp(Type type) {
		return switch(type) {
					BoolType: "SB "
					DoubleType: "FSW "
					default: "SW "
				}		
	}
	
	def loadOp(Type type) {
		return switch(type) {
					BoolType: "LB "
					DoubleType: "FLW "
					default: "LW "
				}		
	}
	
	def allocateAddr(Type type) {
		var temp = memoryAddr
		memoryAddr += type.dataSize
		return temp
	}
	
	def MetaData getScalaMeta(Type type) {
		var meta = new MetaData
		meta.type = xsemantics.copytype(type).value
		meta.address = allocateAddr(type)
		return meta
	}
	
	def hex(int dec) {
		return "0x" + Integer.toHexString(dec)
	}
	
	def writeFile() {
		fsaGlobal.generateFile(fileName, output)
	}
	
	def fetchConfig(EObject e, String item, String field) {
		var opaque = config.get(item)
		if (opaque === null) {
			throw new IOException("[fetchConfig] Cannot find the configuration for " + item)
		}
		for (sec: opaque.field) {
			if (sec.name.equals(field)) {
				return sec.value.string ?: sec.value.inti / 20
			}
		}
	}
}
