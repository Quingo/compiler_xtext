/*
 * generated by Xtext 2.20.0
 */
package org.qdt.quingo.generator

import com.google.inject.Inject
import eqasm.QubitPair
import java.io.IOException
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.nodemodel.ICompositeNode
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.junit.jupiter.api.Assertions
import org.qdt.quingo.quingo.Add
import org.qdt.quingo.quingo.And
import org.qdt.quingo.quingo.ArrayAccess
import org.qdt.quingo.quingo.ArrayType
import org.qdt.quingo.quingo.Assignment
import org.qdt.quingo.quingo.BlockStatement
import org.qdt.quingo.quingo.BoolType
import org.qdt.quingo.quingo.BooleanLiteral
import org.qdt.quingo.quingo.BreakStatement
import org.qdt.quingo.quingo.ContinueStatement
import org.qdt.quingo.quingo.DoubleLiteral
import org.qdt.quingo.quingo.DoubleType
import org.qdt.quingo.quingo.EmptyStatement
import org.qdt.quingo.quingo.Equal
import org.qdt.quingo.quingo.ExpArray
import org.qdt.quingo.quingo.ExpFunctionCall
import org.qdt.quingo.quingo.ExpLength
import org.qdt.quingo.quingo.ExpTuple
import org.qdt.quingo.quingo.ExpVariable
import org.qdt.quingo.quingo.Expression
import org.qdt.quingo.quingo.ForStatement
import org.qdt.quingo.quingo.FormalParameter
import org.qdt.quingo.quingo.FunDeclaration
import org.qdt.quingo.quingo.FunctionCall
import org.qdt.quingo.quingo.FunctionType
import org.qdt.quingo.quingo.IfStatement
import org.qdt.quingo.quingo.IntLiteral
import org.qdt.quingo.quingo.IntType
import org.qdt.quingo.quingo.LocalVarDecl
import org.qdt.quingo.quingo.Mult
import org.qdt.quingo.quingo.NEqual
import org.qdt.quingo.quingo.OpAssignment
import org.qdt.quingo.quingo.Opaque
import org.qdt.quingo.quingo.Or
import org.qdt.quingo.quingo.Program
import org.qdt.quingo.quingo.QubitType
import org.qdt.quingo.quingo.QuingoFactory
import org.qdt.quingo.quingo.ReturnStatement
import org.qdt.quingo.quingo.Statement
import org.qdt.quingo.quingo.SwitchStatement
import org.qdt.quingo.quingo.TimerDeclaration
import org.qdt.quingo.quingo.TimingConstraint
import org.qdt.quingo.quingo.ToDouble
import org.qdt.quingo.quingo.ToInt
import org.qdt.quingo.quingo.TupleType
import org.qdt.quingo.quingo.Type
import org.qdt.quingo.quingo.Unary
import org.qdt.quingo.quingo.UnitType
import org.qdt.quingo.quingo.UsingStatement
import org.qdt.quingo.quingo.Variable
import org.qdt.quingo.quingo.VariableInit
import org.qdt.quingo.quingo.WaitStatement
import org.qdt.quingo.quingo.WhileStatement
import org.qdt.quingo.typing.QuingoSemantics

import static org.qdt.quingo.generator.Configuration.*
import static org.qdt.quingo.generator.EqasmBackend.*
import static org.qdt.quingo.generator.StringToReg.*

import static extension org.qdt.quingo.generator.Serializer.*

/**
 * Generates eQASM code from AST.
 * 
 * @author Jintao Yu, Xiang Fu
 */
class QuingoGenerator extends AbstractGenerator {

    /**
     * Create an IntType
     */
    static val QuingoIntType    = QuingoFactory::eINSTANCE.createIntType

    /**
     * Create a BoolType
     */
    static val QuingoBoolType   = QuingoFactory::eINSTANCE.createBoolType

    /**
     * Create a QubitType
     */
    static val QuingoQubitType  = QuingoFactory::eINSTANCE.createQubitType

    /**
     * Create a DoubleType
     */
    static val QuingoDoubleType = QuingoFactory::eINSTANCE.createDoubleType

    /**
     * the first unused S register
     */
    int sIndex

    /**
     * the first unused R register
     */
    int iIndex

    /**
     * the first unused F register
     */
    int fIndex

    /**
     * the duration of current quantum operation
     */
    int duration

	/**
	 * the index of IfStatement
	 */
    int ifIndex

	/**
	 * the index of WhileStatement
	 */
    int whileIndex
    
    /**
     * the index of SwitchStatement
     */
    int switchIndex
    
    /**
     * the index of arrays
     */
    int arrayIndex
    
    /**
     * the index of non-opaque function calls
     */
    int funIndex

	/**
	 * opaque gates configuration 
	 */
    HashMap<String, Opaque> config
    
    /**
     * match an AST node to its index
     */
    HashMap<EObject, Integer> mapAstNodeToIndex
    
    /**
     * record the variables assigned in a loop body
     */
    HashMap<WhileStatement, HashSet<String>> mapWhileToVarSet
    
    /**
     * record the MetaData that is stored in the registers
     */
    HashMap<String, MetaData> mapRegToMetadata
    
    /**
     * record the index of a timer
     */
    HashMap<TimerDeclaration, Integer> timerMap

	/**
	 * the starting address of the free memory space
	 */
    int memoryAddr
    
    /**
     * the IFileSystemAccess2 passed to doGenerate
     */
    IFileSystemAccess2 fsaGlobal
    
    /**
     * the name of the generated eQASM file
     */
    String fileName
    
    /**
     * specify whether the current expression is on the left side in an assignment statement
     */
    Boolean bExprOnLeftSide
    
    /**
     * record the global time
     */
    int global

	/**
	 * the type system of Quingo
	 * <p>
	 * It contains functions and validations related to types.
	 */
    @Inject	QuingoSemantics xsemantics

	/**
	 * The entry point of QuingoGenerator class.
	 * 
	 * @param resource  the source file being compiled
	 * @param fsa       the file system to write the generated file
	 * @param context   not used
	 */
     override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

        // Global variable initialization
        sIndex = 0
        iIndex = 3 // r0 for false, r1 for true, r2 for freeAddr
        fIndex = 1 // f0 for 0.0
        duration = 1

        ifIndex = 0
        whileIndex = 1 // must be positive since its sign is used in compiling CONTINUE statements
        arrayIndex = 0
        switchIndex = 0
        funIndex = 0

        config            = new HashMap<String, Opaque>
        mapAstNodeToIndex = new HashMap<EObject, Integer>
        mapWhileToVarSet  = new HashMap<WhileStatement, HashSet<String>>
        mapRegToMetadata  = new HashMap<String, MetaData>
        timerMap          = new HashMap<TimerDeclaration, Integer>

        memoryAddr = Configuration.staticAddr + Serializer.INT_SIZE // [Configuration.staticAddr] = 0
        fsaGlobal = fsa
        bExprOnLeftSide = false
        global = 0

        resetBackend()  // clear instructions previously
        
        // Optimize AST
        var resourceSet = resource.resourceSet
        resourceSet.decomposeForLoop

		// search and process the configuration files
        for (res : resourceSet.resources) {
            if (res.URI.fileExtension == "qfg") {
                var prog = res.contents.head as Program
                for (opaque: prog?.eAllContents.toIterable.filter(Opaque)) {

                    // Check whether the duration of measure is legal
                    var measure = false
                    var value = 0
                    for (sec: opaque.field) {
                        if (sec.name.equals("type") && sec.value.string == "meas") {
                            measure = true
                        }
                        if (sec.name.equals("duration")) {
                            value = sec.value.inti
                        }
                    }
                    if (measure && value < 60) {
                        System.err.println("Measure's duration is not allowed to be under 60!")
                        Configuration.exitCode = -2
                        return
                    }

                    config.put(opaque.name, opaque)
                }
            }
        }

		// search and process the configuration files
        for (nodeFuncDecl : resource.allContents.toIterable.filter(FunDeclaration)) {
            if (nodeFuncDecl.name.equals("main")) {
                var index = funIndex++
                mapAstNodeToIndex.put(nodeFuncDecl, index)
                addInitInstructions()

				// decide the name of the output file
                if (Configuration.outputFile != "") {
                    fileName = Configuration.outputFile
                }
                else {
                    fileName = "build/" + resource.URI.trimFileExtension.lastSegment + ".eqasm"
                }
                
                // the actual compilation
                try {
                    var map = new HashMap<String, MetaData>
                    for (par: nodeFuncDecl.pars) {
                        par.compile(map)
                    }
                    nodeFuncDecl.block?.compile(map)
                }
                catch (Exception e) {
                    e.printStackTrace()
                    System.err.println("Except happens at line number: " + e.getStackTrace.get(0).getLineNumber)

                    Configuration.exitCode = -2
                }

                addEndInstructions()
                writeInsnToFile()
            }
        }
    }

    /**
     * Replace a ForStatement with an equivalent WhileStatement
     * <p>
     * A ForStatement has the following structure:
     * <pre>
     *   "for" "(" initExpression=ForInitStatment condExpression=Expression ";" loopExpression=StatementNoColon? ")"
     *     loopBody=BlockStatement;</pre>
     *
     * The decomposition will result in the following structure:
     * <pre>
     *    ForInitStatment
     *    "while (" condExpression ") {"
     *      loopBody.stats
     *      loopExpression
     *    "}"</pre> 
     * @param rs  the ResourceSet of the project
     */
    def void decomposeForLoop(ResourceSet rs) {
        for (res : rs.resources) {
        	var prog = res.contents.head as Program
        	if (prog !== null && prog.elements !== null) {
	        	for (element: prog.elements) {
	        		element?.fun?.block?.decomposeForLoop
	        	}
        	}
        }
    }
    
    /**
     * Replace a ForStatement with an equivalent WhileStatement.
     * 
     * @param blockStatment  a BlockStatment that may contain a for-loop
     */
    def void decomposeForLoop(BlockStatement blockStatement) {
    	var statList = blockStatement.stats
    	for (var i = 0; i < statList.length; i++) {
    		val stat = statList.get(i)
    		if (stat instanceof ForStatement) {
    			stat.loopBody.decomposeForLoop

		    	if (stat.loopExpression !== null) {
			    	stat.loopBody.stats.add(stat.loopExpression)
		    	}
		    	var whileStat = QuingoFactory::eINSTANCE.createWhileStatement => [
		    		it.condExpression = stat.condExpression
		    		it.whileBody = stat.loopBody
		    	]

				// Pack the init statement and WhileStatment into a new BlockStatment
		    	var newBlock = QuingoFactory::eINSTANCE.createBlockStatement
		    	newBlock.stats.add(stat.initExpression)
		    	newBlock.stats.add(whileStat)
		
				// Replace the ForStatement with the new BlockStatement
		    	statList.set(i, newBlock)
    		}
    		else if (stat instanceof BlockStatement) {
    			stat.decomposeForLoop
    		}
    		else if (stat instanceof UsingStatement) {
    			stat.block.decomposeForLoop
    		}
    		else if (stat instanceof WhileStatement) {
    			stat.whileBody.decomposeForLoop
    		}
    		else if (stat instanceof IfStatement) {
    			stat.ifStat.decomposeForLoop
    			stat.elseStat?.decomposeForLoop
    		}
    	}
    }

	/**
	 * Compile a FormalParameter.
	 * 
	 * @param nodeFormalParam  an AST node of FormalParameter type
	 * @param map              the symbol table of current operation
	 * @return                 a MetaData that contains the parameter's information
	 */
    def dispatch MetaData compile(FormalParameter nodeFormalParam, HashMap<String, MetaData> map) {
    	
    	// rename a parameter that has the same name as previous variables
        while (map.containsKey(nodeFormalParam.name)) {
            nodeFormalParam.name = nodeFormalParam.name + "-2";
        }
        
        return allocRegForVariable(nodeFormalParam.name, nodeFormalParam.type, map)
    }

	/**
	 * Compile a LocalVarDecl.
	 * 
	 * @param nodeVarDecl  an AST node of LocalVarDecl type
	 * @param map          the symbol table of current operation
	 * @return             null
	 */
    def dispatch MetaData compile(LocalVarDecl nodeVarDecl, HashMap<String, MetaData> map) {
        for (init: nodeVarDecl.init) {
            init.compile(map)
        }
        return null
    }

	/**
	 * Compile a VariableInit.
	 * 
	 * @param nodeVarWithInit  an AST node of VariableInit type
	 * @param map              the symbol table of current operation
	 * @return                 a MetaData that contains the variable's information
	 */
    def dispatch MetaData compile(VariableInit nodeVarWithInit, HashMap<String, MetaData> map) {
        var varName = nodeVarWithInit.varName

    	// rename a variable that has the same name as previous variables
        while (map.containsKey(varName.name)) {
            varName.name = varName.name + "-2";
        }
        // get the type of this variable
        var typeVariable = (nodeVarWithInit.eContainer as LocalVarDecl).type

        var meta = allocRegForVariable(varName.name, typeVariable, map)
        if (nodeVarWithInit.value !== null) {
            assignMetaData(meta, nodeVarWithInit.value.compile(map), typeVariable,
                           NodeModelUtils.getNode(nodeVarWithInit))
        }
        return meta
    }

	/**
	 * Compile a BlockStatement.
	 * <p>
	 * The statements contained in the BlockStatment are compiled sequentially. However,
	 * ReturnStatement may interrupt it.
	 * 
	 * @param stat  an AST node of BlockStatement type
	 * @param map   the symbol table of current operation
	 * @return      a MetaData if containing ReturnStatment, ContinueStatement, or BreakStatement; otherwise, null
	 */
    def dispatch MetaData compile(BlockStatement stat, HashMap<String, MetaData> map) {
        if (stat.stats !== null) {
            for (st: stat.stats) {
                var meta = st.compile(map)
                
                // only return statements and structures containing 'return' will return non-null meta
                if (meta !== null) {
                    return meta
                }
            }
        }
        return null
    }

	/**
	 * Compile a WaitStatement.
	 * 
	 * @param stat  an AST node of WaitStatement type
	 * @param map   the symbol table of current operation
	 * @return      null
	 * 
	 * @deprecated  WatiStatment is replaced by timing constraints.
	 */
    def dispatch MetaData compile(WaitStatement stat, HashMap<String, MetaData> map) {
    	var metaWaitTime = stat.lis.get(stat.lis.length - 1).compile(map)
        if (metaWaitTime.valid.constant) {      // if the waiting time is already known
            val immWaitTime = metaWaitTime.value as Integer
            genInsnWait(immWaitTime)
        } 
        else {                                // otherwise, in the register (int-type meta)
            var reg = metaWaitTime.register
            genInsnWait(reg)
        }
        return null
    }

	/**
	 * Compile a ReturnStatement.
	 * <p>
	 * This function behaves differently depending on whether the contain operation is "main".
	 * If it is the main operation, the returned values are written to the shared memory.
	 * Otherwise, it is returned in the form of a MetaData.
	 * 
	 * @param stat  an AST node of ReturnStatement type
	 * @param map   the symbol table of current operation
	 * @return      the MetaData compiled from the returned expression
	 */
    def dispatch MetaData compile(ReturnStatement retStat, HashMap<String, MetaData> map) {
        var container = retStat.eContainer
        
        // find the FunDeclaration that the ReturnStatement belongs to
        while (!(container instanceof FunDeclaration)) {
            container = container.eContainer
        }

        var MetaData metaRetValue = null
        if (retStat.value === null) {
            metaRetValue = new MetaData // use a fresh new metadata to represent the returned nothing.
        }
        else {  // retStat.value !== null
            metaRetValue = retStat.value.compile(map)

            var fun = container as FunDeclaration
            if (fun.name.equals("main")) {
                // serialize and export the data to shared memory using exportMetaData
                var metaMockStackPtr   = new MetaData
                metaMockStackPtr.type  = new PointerType
                metaMockStackPtr.value = 0
                var regMockStackPtr    = metaMockStackPtr.register
                metaMockStackPtr.valid.setOnlyReg

                // load the shared memory address to the `regMockStackPtr` register
                loadImmToReg(strToGPR(regMockStackPtr), Configuration.sharedAddr,
                             'load shared memory address to regMockStackPtr')

                var metaMockHeapPtr   = new MetaData
                metaMockHeapPtr.type  = new PointerType
                metaMockHeapPtr.value = 0
                var regMockHeapPtr    = metaMockHeapPtr.register
                loadImmToReg(strToGPR(regMockHeapPtr), Configuration.sharedAddr,
                             'load shared memory address to regMockHeapPtr')

                metaMockHeapPtr.valid.setOnlyReg
                exportMetaData(metaMockStackPtr, metaMockHeapPtr, metaRetValue, fun.type)
            }
            else {  // not main function
                if (!(fun.type instanceof UnitType)) {
                    var ret = map.get("return")
                    assignMetaData(ret, metaRetValue, fun.type, NodeModelUtils.getNode(retStat))
                }
            }
        }
        // jump to function end
        var funcEndLabel = genFuncEndLabel(mapAstNodeToIndex.get(container))
        insertQasmGoto(funcEndLabel)

        return metaRetValue
    }

	/**
	 * Compile a FunctionCall.
	 * 
	 * @param call  an AST node of FunctionCall type
	 * @param map   the symbol table of current operation
	 * @return      null
	 */
    def dispatch MetaData compile(FunctionCall call, HashMap<String, MetaData> map) {
    	call.exp.compile(map)
        return null
    }

	/**
	 * Compile a ContinueStatement.
	 * 
	 * @param stat  an AST node of ContinueStatement type
	 * @param map   the symbol table of current operation
	 * @return      a dummy MetaData indicating an interruption of sequential execution
	 * 
	 * @see #compile(WhileStatement, HashMap<String, MetaData>)
	 */
    def dispatch MetaData compile(ContinueStatement stat, HashMap<String, MetaData> map) {
    	
    	// find the right container
        var container = stat.eContainer
        while (!(container instanceof WhileStatement || container instanceof ForStatement)) {
            container = container.eContainer
        }
        
        var continueindex = mapAstNodeToIndex.get(container)
        if (continueindex.intValue > 0) {
	        var varSet = mapWhileToVarSet.get(container)
	        storeVarsToMem(varSet, map, false)
            
            // jump back to loop start
	        var loopStartLabel = genLoopStartLabel(continueindex)
	        insertQasmGoto(loopStartLabel)
        }
        return new MetaData
    }

	/**
	 * Compile a BreakStatement.
	 * 
	 * @param stat  an AST node of BreakStatement type
	 * @param map   the symbol table of current operation
	 * @return      a dummy MetaData indicating an interruption of sequential execution
	 * 
	 * @see #compile(WhileStatement, HashMap<String, MetaData>)
	 */
    def dispatch MetaData compile(BreakStatement stat, HashMap<String, MetaData> map) {

    	// find the right container
        var container = stat.eContainer
        while (!(container instanceof WhileStatement || container instanceof ForStatement
          || container instanceof SwitchStatement)) {
            container = container.eContainer
        }

        var breakindex = Math.abs(mapAstNodeToIndex.get(container))
        var varSet = mapWhileToVarSet.get(container)
        storeVarsToMem(varSet, map, false)
        
        // jump to loop end
        var loopEndLabel = genLoopEndLabel(breakindex)
        insertQasmGoto(loopEndLabel)
        return new MetaData
    }

	/**
	 * Compile a WhileStatement.
	 * <p>
	 * We try to unroll the loop up to {@link Configuration.maxUnrolling} times.
	 * Beyond that, the loop keeps its original form, i.e., consisting of a branch instruction
	 * and several labels.
	 * <p>
	 * The unrolling is only possible when the condition is constant, i.e., can be evaluated 
	 * during compilation time.
	 * 
	 * @param whileStatement  an AST node of WhileStatement type
	 * @param map             the symbol table of current operation
	 * @return                null
	 */
    def dispatch MetaData compile(WhileStatement whileStatement, HashMap<String, MetaData> map) {

		// The ContinueStatement and BreakStatement work differently during loop-unrolling.
		// BreakStatement works the same as not unrolling, i.e., jumping to the end of the loop.
		// However, there is no labels for ContinueStatment to jump to. Instead, it only needs
		// to end the compilation of a BlockStatment early. Here, we assign the index to a
		// negative number to mark the differences.
        var tempwhileindex = whileIndex++
        mapAstNodeToIndex.put(whileStatement, -tempwhileindex)

        var whileStartLabel = genLoopStartLabel(tempwhileindex)
        var whileEndLabel = genLoopEndLabel(tempwhileindex)

        var metaCondResult = whileStatement.condExpression.compile(map)
        var count = 0  // count how many times the loop have been unrolled
        
        var containBreakOrContinue = whileStatement.whileBody.containBreakOrContinue
        while (metaCondResult.valid.constant && !containBreakOrContinue) {

            if (metaCondResult.value as Boolean) {  // the while condition is true

                // unroll the loop by compiling the body
                if (whileStatement.whileBody.compile(map) !== null) {  // if containing return, break, etc.
	                genQasmLabel(whileEndLabel)
                	return null
                }
                metaCondResult = whileStatement.condExpression.compile(map) // update the condition
            } 
            else {                                // the while condition is false
            
                // upon loop exit, generate the loop end label.
                genQasmLabel(whileEndLabel)
                return null
            }

            count++
            if (count >= Configuration.maxUnrolling) { // after maxUnrolling times, use instructions for the loop
                genQasmComment("Unrolling is up to " + count + " loops")
                metaCondResult.valid.setOnlyReg
            }
        }

        // get all array variables (ExpVariable) in the while body
        var set = new HashSet<String>
        for (v: whileStatement.eAllContents.toIterable.filter(ExpVariable)) {
            set.add(v.value.name)
        }
        if (containBreakOrContinue) {
        	mapWhileToVarSet.put(whileStatement, set)
        }

        // store the array to the memory
        storeVarsToMem(set, map, true)

        // Both ContinueStatement and BreakStatement jump to labels, so we change
        // the index to a positive number.
        mapAstNodeToIndex.put(whileStatement, tempwhileindex)

        // -------------- use instructions to implement the while loop ---------------

        // generate a start label for the while loop
        genQasmLabel(whileStartLabel)

        // if the result is not true, goto while end label (skip the while body)
        metaCondResult = whileStatement.condExpression.compile(map)
        var insn = gotoLabelIfNotEqual(metaCondResult.register, 'r1', whileEndLabel)
        insn.setTrailingComment("skip the while body if condition not satisfied.")
        
        // generate instructions for the while body
        whileStatement.whileBody.compile(map)
        storeVarsToMem(set, map, true)

        // unconditionally jump back to the loop start to evaluate the while condition
        insertQasmGoto(whileStartLabel)

        // add the while end label after the entire while body
        genQasmLabel(whileEndLabel)

        // remove the variable set since it may occupy space
        if (containBreakOrContinue) {
        	mapWhileToVarSet.remove(whileStatement)
        }
        return null
    }

	/**
	 * Compile a SwitchStatement.
	 * 
	 * @param switchStatement  an AST node of SwitchStatement type
	 * @param map              the symbol table of current operation
	 * @return                 null
	 * 
	 * @deprecated SwitchStatement will be removed from Quingo
	 */
    def dispatch MetaData compile(SwitchStatement switchStatement, HashMap<String, MetaData> map) {

        if (switchStatement.switchBody === null) {  // no cases inside, skip
            return null
        }

        var metaSwitchValue = switchStatement.expSwitchValue.compile(map)
        if (metaSwitchValue.valid.constant) {
            var match = false
            var count = switchStatement.switchBody.size
            var i = 0

            for (i = 0; i < count; i++) {

                var labeledBlock = switchStatement.switchBody.get(i)

                if (match && labeledBlock.caseActionStats !== null) {
                    labeledBlock.caseActionStats.compile(map)
                    return null
                }

                var metaCaseValue = labeledBlock.expCaseValue.compile(map)

                if (metaCaseValue.valid.constant) {
                    match = metaSwitchValue.value == metaCaseValue.value

                } else {
                    i = count + 1     // break;

                }
            }

            if (i === count) {        // all the cases are constant
                switchStatement.defaultBlock.caseActionStats.compile(map)
                return null
            }
        }

        var index = switchIndex++
        mapAstNodeToIndex.put(switchStatement, index)
        var switchBody = switchStatement.switchBody

        /**
         * Consider the following switch statement:
         * ```quingo
         * switch(a) {
         *     case 0:
         *     case 1: // do sth here.
         *     case 2:
         *     case 3: // do some other thing here.
         *     default:
         * }
         * ```
         * if a is 2, then it should directly jump to and execute the code in case 3, since
         * case 2 is empty.
         *
         * `indexNextActionBlock[i]` stores the index of the first following block which contains actions after
         *   the i-th case. `indexNextActionBlock[i]` being -1 means it is one of consecutive empty
         *   cases in the end.
         */
        var length = switchBody.length
        var indexNextActionBlock = newIntArrayOfSize(length + 1)
        indexNextActionBlock.set(length, -1)

        for (var i = length - 1; i >= 0; i--) {
            if (switchBody.get(i).caseActionStats === null) {
                indexNextActionBlock.set(i, indexNextActionBlock.get(i + 1))
            } 
            else {
                indexNextActionBlock.set(i, i)
            }
        }

        map.storeToMem

        // the register storing the value of `xxx` inside `switch(xxx)`
        var regSwitchValue = metaSwitchValue.register

        for (var i = 0; i < switchBody.length; i++) {           // handle each case

            if (indexNextActionBlock.get(i) !== -1) {            // skip the last empty ones

                var caseStartLabel = genCaseStartLabel(index, i)
                var caseEndLabel = genCaseEndLabel(index, i)

                var labeledBlock = switchBody.get(i)
                var metaCaseValue = labeledBlock.expCaseValue.compile(map)
                var regCaseValue = metaCaseValue.register

                if (labeledBlock.caseActionStats === null) {

                    gotoLabelIfEqual(regSwitchValue, regCaseValue, caseStartLabel)
                } 
                else {
                    gotoLabelIfNotEqual(regSwitchValue, regCaseValue, caseEndLabel)
                    genQasmLabel(caseStartLabel)
                    labeledBlock.caseActionStats.compile(map)
                    genQasmLabel(caseEndLabel)
                }
            }
        }

        switchStatement.defaultBlock?.caseActionStats?.compile(map)
        genQasmLabel(genLoopEndLabel(index))
        return null
    }

	/**
	 * Compile an IfStatement.
	 * <p>
	 * When the condition is constant, the IfStatement is resolved to either the if block or the else block.
	 * Otherwise, both blocks are compiled and their execution depends on the branch instruction.
	 * 
	 * @param stat  an AST node of IfStatement type
	 * @param map   the symbol table of current operation
	 * @return      a MetaData if containing ReturnStatment, ContinueStatement, or BreakStatement; otherwise, null
	 */
    def dispatch MetaData compile(IfStatement stat, HashMap<String, MetaData> map) {
        var condition = stat.expression.compile(map)
        if (condition.valid.constant) {  // the if-else can be statically resolved
            if (condition.value as Boolean) { // condition == true
            	return stat.ifStat.compile(map)
            }
            else { // condition == false
            	return stat.elseStat?.compile(map)
            }
        }

        // using instructions to do if-else.
        var set = collectVariable(stat.ifStat)
        storeVarsToMem(set, map, true)

        var index = ifIndex++
        var creg = condition.register
        var ifElseLabel = genIfElseLabel(index)
        var ifEndLabel = genIfEndLabel(index)
        if (stat.elseStat === null) {   // only if, no else
            gotoLabelIfNotEqual(creg, 'r1', ifEndLabel)
            stat.ifStat.compile(map)
            storeVarsToMem(set, map, true)
            genQasmLabel(ifEndLabel)
        } 
        else {                        // if with the else branch
            // condition unsatisfied, goto else body
            gotoLabelIfNotEqual(creg, 'r1', ifElseLabel)

            stat.ifStat.compile(map)                // if body
            storeVarsToMem(set, map, true)
            insertQasmGoto(ifEndLabel)              // go to the end
            genQasmLabel(ifElseLabel)               // else body

            var elseSet = collectVariable(stat.elseStat)
            storeVarsToMem(elseSet, map, true)
            
            stat.elseStat.compile(map)
            storeVarsToMem(elseSet, map, true)
            genQasmLabel(ifEndLabel)          // if structure end
        }
        return null
    }

	/**
	 * Compile an Assignment.
	 * 
	 * @param assignment  an AST node of Assignment type
	 * @param map         the symbol table of current operation
	 * @return            null
	 */
    def dispatch MetaData compile(Assignment assignment, HashMap<String, MetaData> map) {
        var metaRightSide = assignment.value.compile(map)

        var leftExp = assignment.left as Expression
        var metaLeftSide = compileLeftHandSideExpression(leftExp, map)

        assignMetaData(metaLeftSide, metaRightSide, getQuingoTypeOfExpr(leftExp),
                       NodeModelUtils.getNode(assignment))
        return null
    }

	/**
	 * Compile an OpAssignment.
	 * 
	 * @param assignment  an AST node of OpAssignment type
	 * @param map         the symbol table of current operation
	 * @return            null
	 */
    def dispatch MetaData compile(OpAssignment assignment, HashMap<String, MetaData> map) {
        var metaRightSide = assignment.right.compile(map)

        var leftExp = assignment.left as Expression
        var metaLeftSide = compileLeftHandSideExpression(leftExp, map)

        var metaOpResult = compileOperator(metaLeftSide, metaRightSide,
                                           assignment.op.replaceFirst("=", ""))

        assignMetaData(metaLeftSide, metaOpResult, getQuingoTypeOfExpr(leftExp),
                       NodeModelUtils.getNode(assignment))
        return null
    }

	/**
	 * Compile a UsingStatement.
	 * 
	 * @param stat  an AST node of UsingStatement type
	 * @param map   the symbol table of current operation
	 * @return      a MetaData if containing ReturnStatment; otherwise, null
	 */
    def dispatch MetaData compile(UsingStatement stat, HashMap<String, MetaData> map) {
        var qnum = 0
        for (par: stat.pars) {
            var meta = allocateQubit(par.name, par.type, map)
            if (meta.link === null) { // if the meta is not an array -> it is a single qubit
                qnum += 1
            } else {                  // the meta is an array
                qnum += meta.value as Integer
            }
        }
        var res = stat.block.compile(map)
        sIndex -= qnum // deallocate qubits
        return res
    }

	/**
	 * Compile an EmptyStatement.
	 * <p>
	 * Do nothing for the EmptyStatement.
	 * 
	 * @param stat  an AST node of EmptyStatement type
	 * @param map   the symbol table of current operation
	 * @return      null
	 */
    def dispatch MetaData compile(EmptyStatement stat, HashMap<String, MetaData> map) {
        return null
    }

	/**
	 * Compile an TimerDeclaration.
	 * 
	 * @param timer  an AST node of TimerDeclaration type
	 * @param map    the symbol table of current operation
	 * @return       null
	 */
    def dispatch MetaData compile(TimerDeclaration timer, HashMap<String, MetaData> map) {
        timerMap.put(timer, global)
        return null
    }

	/**
	 * Compile an TimingConstraint.
	 * 
	 * @param stat  an AST node of TimingConstraint type
	 * @param map   the symbol table of current operation
	 * @return      null
	 */
    def dispatch MetaData compile(TimingConstraint stat, HashMap<String, MetaData> map) {
        var timer = timerMap.get(stat.timer)
        var meta = stat.value.compile(map)
        var delay = timer + meta.value as Integer - global
        genInsnWait(delay)
        global += delay
        return null
    }

	/**
	 * Compile an ExpFunctionCall.
	 * 
	 * @param exp  an AST node of ExpFunctionCall type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ExpFunctionCall exp, HashMap<String, MetaData> map) {
        return compileFunctionCall(exp.fun, exp.pars, map, NodeModelUtils.getNode(exp))
    }

	/**
	 * Compile an Or expression.
	 * <p>
	 * When the operands are both constant, the result is calculated during compilation time.
	 * Otherwise, an eQASM OR instruction is generated.
	 * 
	 * @param exp  an AST node of Or type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(Or exp, HashMap<String, MetaData> map) {
        var metaLeftOperand = exp.left.compile(map)
        var metaRightOperand = exp.right.compile(map)
        if (metaLeftOperand.valid.constant && metaRightOperand.valid.constant) {
            return new MetaData(metaLeftOperand.value as Boolean || metaRightOperand.value as Boolean)
        }
        
        // When (a) operands are unknown during compilation
        var regLeftOperand = metaLeftOperand.register
        var regRightOperand = metaRightOperand.register
        var metaResult = allocMetaAndStackForType(QuingoBoolType)
        var regOrResult = metaResult.register
        genInsnOrRegs(regOrResult, regLeftOperand, regRightOperand)
        return metaResult
    }

	/**
	 * Compile an And expression.
	 * <p>
	 * When the operands are both constant, the result is calculated during compilation time.
	 * Otherwise, an eQASM AND instruction is generated.
	 * 
	 * @param exp  an AST node of And type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(And exp, HashMap<String, MetaData> map) {
        var metaLeftOperand = exp.left.compile(map)
        var metaRightOperand = exp.right.compile(map)
        if (metaLeftOperand.valid.constant && metaRightOperand.valid.constant) {
            return new MetaData(metaLeftOperand.value as Boolean && metaRightOperand.value as Boolean)
        }

        // When (a) operands are unknown during compilation
        var regLeftOperand = metaLeftOperand.register
        var regRightOperand = metaRightOperand.register
        var metaResult = allocMetaAndStackForType(QuingoBoolType)
        genInsnAndRegs(metaResult.register, regLeftOperand, regRightOperand)
        return metaResult
    }

	/**
	 * Compile an Add expression.
	 * 
	 * @param exp  an AST node of Add type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(Add exp, HashMap<String, MetaData> map) {
        var metaLeftOperand = exp.left.compile(map)
        var metaRightOperand = exp.right.compile(map)
        return compileOperator(metaLeftOperand, metaRightOperand, exp.op)
    }

	/**
	 * Compile an Mult expression.
	 * 
	 * @param exp  an AST node of Mult type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(Mult exp, HashMap<String, MetaData> map) {
        var metaLeftOperand = exp.left.compile(map)
        var metaRightOperand = exp.right.compile(map)
        return compileOperator(metaLeftOperand, metaRightOperand, exp.op)
    }

	/**
	 * Compile an Equal expression.
	 * <p>
	 * When the operands are both constant, the result is calculated during compilation time.
	 * Otherwise, eQASM instructions are generated.
	 * 
	 * @param exp  an AST node of Equal type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(Equal exp, HashMap<String, MetaData> map) {
        var metaLeftOperand = exp.left.compile(map)
        var metaRightOperand = exp.right.compile(map)

        if (metaLeftOperand.valid.constant && metaRightOperand.valid.constant) {
            if (exp.op == "==") {
                return new MetaData(metaLeftOperand.value == metaRightOperand.value)
            } 
            else { // exp.op == "!="
                return new MetaData(metaLeftOperand.value != metaRightOperand.value)
            }
        }

        // When (a) operands are unknown during compilation
        var regLeftOperand = metaLeftOperand.register
        var regRightOperand = metaRightOperand.register
        var metaResult = allocMetaAndStackForType(QuingoBoolType)
        genInsnsCheckEquality(metaResult.register, regLeftOperand, regRightOperand, exp.op, metaLeftOperand.type)
        return metaResult
    }

	/**
	 * Compile an NEqual expression.
	 * <p>
	 * When the operands are both constant, the result is calculated during compilation time.
	 * Otherwise, eQASM instructions are generated.
	 * 
	 * @param exp  an AST node of NEqual type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(NEqual exp, HashMap<String, MetaData> map) {
        var metaLeftOperand = exp.left.compile(map)
        var metaRightOperand = exp.right.compile(map)

        if (metaLeftOperand.valid.constant && metaRightOperand.valid.constant) {
            if (metaLeftOperand.type instanceof DoubleType) {
                var floatLeftOperand = metaLeftOperand.value as Float
                var floatRightOperand = metaRightOperand.value as Float
                return switch (exp.op) {
                    case "<":
                        new MetaData(floatLeftOperand < floatRightOperand)
                    case "<=":
                        new MetaData(floatLeftOperand <= floatRightOperand)
                    case ">=":
                        new MetaData(floatLeftOperand >= floatRightOperand)
                    case ">":
                        new MetaData(floatLeftOperand > floatRightOperand)
                }
            } 
            else { // metaLeftOperand.type instanceof IntType
                var intLeftOperand = metaLeftOperand.value as Integer
                var intRightOperand = metaRightOperand.value as Integer
                return switch (exp.op) {
                    case "<":
                        new MetaData(intLeftOperand < intRightOperand)
                    case "<=":
                        new MetaData(intLeftOperand <= intRightOperand)
                    case ">=":
                        new MetaData(intLeftOperand >= intRightOperand)
                    case ">":
                        new MetaData(intLeftOperand > intRightOperand)
                }
            }
        }

        // When (a) operands are unknown during compilation
        var regLeftOperand = metaLeftOperand.register
        var regRightOperand = metaRightOperand.register
        var type = metaLeftOperand.type
        var metaResult = allocMetaAndStackForType(QuingoBoolType)
        var regResult = metaResult.register
        genInsnsPOCmp(regResult, regLeftOperand, regRightOperand, exp.op, type)
        return metaResult
    }

	/**
	 * Compile a Unary expression.
	 * <p>
	 * When the operand is constant, the result is calculated during compilation time.
	 * Otherwise, eQASM instructions are generated.
	 * 
	 * @param exp  an AST node of Unary type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(Unary exp, HashMap<String, MetaData> map) {
        var metaResult = exp.final.compile(map)
        if (exp.op == "+") {
            return metaResult
        }

        if (metaResult.valid.constant) {
            if (exp.op == "-") {
                if (metaResult.value instanceof Integer) {
                    return new MetaData(-(metaResult.value as Integer))
                } else if (metaResult.value instanceof Float) {
                    return new MetaData(-(metaResult.value as Float))
                }

            } else if (exp.op == "!") {
                return new MetaData(!(metaResult.value as Boolean))

            } else {
                throw new Exception("Found undefined unary operation " + exp.op)
            }
        }

        // When the operand is unknown during compilation
        metaResult.register
        var metaResult2 = allocMetaAndStackForType(metaResult.type)
        genInsnForUnary(metaResult2.register, metaResult.reg, exp.op, metaResult.type)
        return metaResult2
    }

	/**
	 * Compile an ExpVariable expression.
	 * <p>
	 * Note that a variable can represent a function. In that case, the function's URI is stored
	 * in the MetaData
	 * <p>
	 * Variables of QubitType are not allowed to place on the left side in an assignment, i.e.,
	 * qubits are unclonable.
	 * 
	 * @param exp  an AST node of ExpVariable type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ExpVariable exp, HashMap<String, MetaData> map) {
        var MetaData meta
        var value = (exp as ExpVariable).value
        if (value instanceof FunDeclaration) {
            meta = new MetaData(EcoreUtil.getURI(exp.value).toString)
        } 
        else { // normal variables
            meta = map.get(exp.value.name)
            if (!bExprOnLeftSide && !meta.valid.atLeastOne && !(meta.type instanceof QubitType)) {
                throw new IOException("The value of variable " + value.name + " in line "
                    + NodeModelUtils.getNode(exp).getStartLine + " of "
                    + exp.eResource.URI.lastSegment + " is undefined!")
            }
        }
        return meta
    }

	/**
	 * Compile an BooleanLiteral expression.
	 * 
	 * @param exp  an AST node of BooleanLiteral type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(BooleanLiteral exp, HashMap<String, MetaData> map) {
        return new MetaData(exp.isTrue)
    }

	/**
	 * Compile an IntLiteral expression.
	 * 
	 * @param exp  an AST node of IntLiteral type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(IntLiteral exp, HashMap<String, MetaData> map) {
        return new MetaData(exp.value)
    }

	/**
	 * Compile an DoubleLiteral expression.
	 * 
	 * @param exp  an AST node of DoubleLiteral type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(DoubleLiteral exp, HashMap<String, MetaData> map) {
        return new MetaData(exp.value)
    }

	/**
	 * Compile an ArrayAccess expression.
	 * <p>
	 * This function is implemented considering mainly three cases:
	 * <p>
	 * 1. If the the array and the index are both known at compilation time, the corresponding MetaData
	 * is returned immediately. Otherwise, for the other two cases, eQASM instructions are generated.
	 * <p>
	 * 2. In most situation, except for case 3, the function returns the indexed element in the array
	 * (encapsulate in a MetaData). This element can be a primitive value or an address that represents
	 * another array.
	 * <p>
	 * 3. If the array consists of primitive values, but it is on the left side of an assignment statement,
	 * the function should not return the indexed value, but the indexed address. We created a PointerType
	 * MetaData for expressing that address
	 * 
	 * @param exp  an AST node of ArrayAccess type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ArrayAccess exp, HashMap<String, MetaData> map) {
        var metaArray = exp.array.compile(map)
        var metaIndex = exp.dim.compile(map)

        if (metaArray.valid.constant) {
            if (metaIndex.valid.constant) {
                var intIndex = convToInt(metaIndex.value)
                // note, the `value` field in the MetaData for an array indicates the length of this array
                var iArrayLength = convToInt(metaArray.value)
                if (intIndex >= iArrayLength) {
                    var node = NodeModelUtils.getNode(exp)
                    throw new IndexOutOfBoundsException(node.getText + " at line " + node.getStartLine
                        + " accesses index " + intIndex + " in an array of size " + iArrayLength
                    )
                }
                return metaArray.link.get(intIndex)     // fetch the element at given index
            } 
            else { // metaIndex.valid.constant == false
                metaArray.storeToMem                    // put this array to memory
            }
        }

        var typeArrayElement = getArrayElementType(getQuingoTypeOfExpr(exp.array))

        /**
         * `exp` appears as a left-value and the element type is not an array type
         *  On the left side means we are going to assign a value to it.
         *  We can only assign values to primitive types, which should not be an array.
         */
        var bPrimitiveValueForAssignment  = bExprOnLeftSide && !(typeArrayElement instanceof ArrayType)
 
        val iArrElementSize   = dataSize(typeArrayElement)
        var String regElement = allocRegister
        var iOffsetCurEleToBodyBaseAddr = 0
        var metaElement                 = new MetaData(regElement)
        metaElement.valid.setOnlyReg

        // calculate shift
        var regArrBodyAddr = metaArray.register
        if (metaIndex.valid.constant) {       // the newest value of the dimension size is in the meta data
            iOffsetCurEleToBodyBaseAddr = iArrElementSize * convToInt(metaIndex.value) + Serializer.INT_SIZE
            if (bPrimitiveValueForAssignment) {
                metaElement.reg   = regArrBodyAddr
                metaElement.value = iOffsetCurEleToBodyBaseAddr
                metaElement.type  = new PointerType
            } 
            else { // not on the left side or a array of arrays 
                loadMemToReg(typeArrayElement, regElement, iOffsetCurEleToBodyBaseAddr, regArrBodyAddr) // actual fetch
                metaElement.type = copyQuingoType(typeArrayElement)
            }
        } 
        else {    // the newest value of the dimension size is not in the meta data
            loadImmToReg(strToGPR(regElement), iArrElementSize)  // regElement = size
            var regIndex = metaIndex.register
            genInsnMulRegs(regElement, regElement, regIndex)     // regElement *= dim

            // regElement += 4 (considering the element that stores the length)
            genInsnAddConst(regElement, Serializer.INT_SIZE)
            genInsnAddRegs(regElement, regArrBodyAddr, regElement)

            if (bPrimitiveValueForAssignment) {
                metaElement.reg = regElement
                metaElement.value = 0
                metaElement.type = new PointerType
            } 
            else { // not on the left side or a array of arrays 
                loadMemToReg(typeArrayElement, regElement, 0, regElement)  // final fetch
                metaElement.type = copyQuingoType(typeArrayElement)
            }
        }
        return metaElement
    }

	/**
	 * Compile an ExpLength expression.
	 * <p>
	 * The function retrieves the length of the array, writes the result in the returned metaLength, 
	 * and generates required instructions to move data.
	 * 
	 * @param exp  an AST node of ExpLength type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ExpLength exp, HashMap<String, MetaData> map) {
        var metaArray = exp.left.compile(map)
        if (metaArray.valid.constant) {
            return new MetaData(metaArray.value as Integer)
        } 

        // metaArray.valid.constant == false
        var metaLength = new MetaData
        loadMemToReg(metaLength.register, 0, metaArray.reg) // load the length of metaArray to `regLength`
        metaLength.valid.setOnlyReg
        return metaLength
    }

	/**
	 * Compile an ExpTuple expression.
	 * <p>
	 * The function compiles the ExpTuple, i.e., a tuple whose elements directly written in parentheses:
	 * (exp0, exp1, ...). The function writes the resultant tuple in metaTupleResult, and generates 
	 * required instructions to move data.
	 * 
	 * @param exp  an AST node of ExpTuple type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ExpTuple exp, HashMap<String, MetaData> map) {
        var iNumOfElementsInTuple = exp.texp.length
        if (iNumOfElementsInTuple === 1) {
            return exp.texp.get(0).compile(map)
        }

        // create a MetaData for the result tuple
        var metaTupleResult   = new MetaData
        metaTupleResult.value = iNumOfElementsInTuple
        metaTupleResult.link  = new ArrayList<MetaData>
        metaTupleResult.type  = QuingoFactory.eINSTANCE.createTupleType

        // assign each of the elements in the tuple
        for (var i = 0; i < iNumOfElementsInTuple; i++) {
            metaTupleResult.link.add(exp.texp.get(i).compile(map))
        }
        return metaTupleResult
    }

	/**
	 * Compile an ExpArray expression.
	 * <p>
	 * As the length of the array is known during compilation (which is {@code exp.exp.length}),
	 * the resultant MetaData's {@code valid} is always constant. However, we still allocate
	 * memory in the QCP for the array, in case it will be stored to memory.
	 * 
	 * @param exp  an AST node of ExpArray type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ExpArray exp, HashMap<String, MetaData> map) {
    	
    	// create the type of the array
        val typeArrayElement = getQuingoTypeOfExpr(exp.exp.get(0))
        var typeArray = QuingoFactory.eINSTANCE.createArrayType => [
            it.ptype = typeArrayElement
        ]

        // create a MetaData for the result array
        var metaArrayResult   = allocMetaAndStackForType(typeArray)
        var iNumOfElements    = exp.exp.length
        metaArrayResult.value = iNumOfElements
        metaArrayResult.valid.setOnlyConstant
        var regArrayResult = metaArrayResult.register       // allocate a register for the resultant array

        // Allocate memory for the array
        loadImmToReg(strToGPR(regArrayResult), memoryAddr)  // load the address to the register
        var iAddrForNextElement = memoryAddr + Serializer.INT_SIZE
        var iElementSize        = dataSize(typeArrayElement)
        memoryAddr              = iAddrForNextElement + iNumOfElements * iElementSize

        // Create array members
        metaArrayResult.link = new ArrayList<MetaData>

        // evaluate each each expression in `{expr0, expr1, ...}` and append it to the element list of metaArrayResult
        for (exprArrayElement : exp.exp) {
            var metaElement = allocMetaAndStackForType(typeArrayElement)
            createMetaData(metaElement, typeArrayElement, null)

            metaElement.address  = iAddrForNextElement
            iAddrForNextElement += iElementSize
            assignMetaData(metaElement, exprArrayElement.compile(map), typeArrayElement,
                           NodeModelUtils.getNode(exprArrayElement))
            metaArrayResult.link.add(metaElement)        // append the element
        }
        return metaArrayResult
    }

	/**
	 * Compile an ToInt expression.
	 * <p>
	 * When the operand is constant, the result is calculated during compilation time.
	 * Otherwise, an eQASM instruction is generated.
	 * 
	 * @param exp  an AST node of ToInt type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ToInt exp, HashMap<String, MetaData> map) {
        var metaExprResult = exp.value.compile(map)
        if (metaExprResult.type instanceof IntType) { // if the operand is already an int, we do not need to convert
            return metaExprResult
        }

        if (metaExprResult.valid.constant) {
            return new MetaData((metaExprResult.value as Float).intValue)
        }

		// metaExprResult.valid.constant == false
        var metaResultInt = allocMetaAndStackForType(QuingoIntType)
        var regFloatValue = metaExprResult.register
        var regResultInt = metaResultInt.register
        genInsnConvFloatToInt(regResultInt, regFloatValue)
        return metaResultInt
    }

	/**
	 * Compile an ToDouble expression.
	 * <p>
	 * When the operand is constant, the result is calculated during compilation time.
	 * Otherwise, an eQASM instruction is generated.
	 * 
	 * @param exp  an AST node of ToDouble type
	 * @param map  the symbol table of current operation
	 * @return     the MetaData that contains the compilation result
	 */
    def dispatch MetaData compile(ToDouble exp, HashMap<String, MetaData> map) {
        var metaExprResult = exp.value.compile(map)
        if (metaExprResult.type instanceof DoubleType) { // if the operand is already a double, we do not need to convert
            return metaExprResult
        }

        if (metaExprResult.valid.constant) {
            return new MetaData((metaExprResult.value as Integer).floatValue)
        }
        
		// metaExprResult.valid.constant == false
        var metaResultFloat = allocMetaAndStackForType(QuingoDoubleType)
        var regResultInt = metaExprResult.register
        genInsnConvIntToFloat(metaResultFloat.register, regResultInt)
        return metaResultFloat
    }

	/**
	 * Collects the variables whose values are modified in a (block) statement.
	 * <p>
	 * This is an useful analysis need for branch structures. The returned variables
	 * need to be stored in memory before and after the branch.
	 * 
	 * @param stat  a statement, typically a BlockStatement
	 * @return      the name of the variables contained in the statement
	 */
    def collectVariable(Statement stat) {
        var ret = new HashSet<String>
        for (assignStatement : stat.eAllContents.toIterable.filter(Assignment)) {
            var exprLeftSide = assignStatement.left
            if (exprLeftSide instanceof ExpVariable) {
                ret.add(exprLeftSide.value.name)        // add the array name
            } 
            else {
                for (v : exprLeftSide.eAllContents.toIterable.filter(ExpVariable)) {
                    ret.add(v.value.name)          // add variables inside a tuple
                }
            }
        }

        for (assignStatement : stat.eAllContents.toIterable.filter(OpAssignment)) {
            var exprLeftSide = assignStatement.left
            if (exprLeftSide instanceof ExpVariable) {
                ret.add(exprLeftSide.value.name)
            } 
            else {
                for (v : exprLeftSide.eAllContents.toIterable.filter(ExpVariable)) {
                    ret.add(v.value.name)
                }
            }
        }
        return ret
    }

    /**
     * Implement a function (operation) call.
     * <p>
     * Operations are of two types: used-defined operation (fun.o == true) and opaque operation (fun.p == true).
     * <p>
     * The returned value (MetaData) is stored in the operation's symbol table using "return" as the key.
     * 
     * @param nodeVariable  an AST node corresponding to a function call
     * @param pars          the actual parameters passed to this function
     * @param map           the symbol table of the parent operation
     * @param node          the concrete AST node to process, which is used to emit error message
     * @return              null if the function type is UnitType; otherwise, return the return value of the function
     */
    def MetaData compileFunctionCall(Variable nodeVariable, EList<Expression> pars,
                                     HashMap<String, MetaData> map, ICompositeNode node) {
        var FunDeclaration fun
        if (nodeVariable instanceof FunDeclaration) { // Normal function call
            fun = nodeVariable
        } 
        else {                           // Higher order function call
            var uri = URI.createURI(map.get(nodeVariable.name).reg)
            fun = nodeVariable.eResource.resourceSet.getEObject(uri, false) as FunDeclaration
        }
        genQasmComment('start of ' + fun.name)

        if (fun.o) {                // an operation
            /** for operations, perform actual function call, which consists of:
             *   1. evaluate actual parameters (if expressions are used, evaluate them)
             *   2. bind the actual parameters to the formal parameters.
             *   3. compile the statements in the function block one by one.
             */
            var index = funIndex++
            mapAstNodeToIndex.put(fun, index)
            var newMap = new HashMap<String, MetaData>

            if (!(fun.type instanceof UnitType)) {
                var ret = allocMetaAndStackForType(fun.type)
                createMetaData(ret, fun.type, newMap)
                newMap.put("return", ret)
            }

            // Compile the parameters in the calling expression/statement
            for (var i = 0; i < pars.size; i++) {
                var metaFormalParam = fun.pars.get(i).compile(newMap)     // formal parameters
                var typeFormalParam = fun.pars.get(i).type
                var metaActualParam = pars.get(i).compile(map)            // actual parameters
                assignMetaData(metaFormalParam, metaActualParam, typeFormalParam, node)
            }

            // Compile default parameters
            for (var i = pars.size; i < fun.pars.size; i++) {
                var metaFormalParam = fun.pars.get(i).compile(newMap)
                var typeFormalParam = fun.pars.get(i).type
                var metaActualParam = fun.pars.get(i).exp.compile(map)
                assignMetaData(metaFormalParam, metaActualParam, typeFormalParam, node)
            }

            // Execute the called operation
            fun.block?.compile(newMap)
            var strFuncEndLabel = genFuncEndLabel(index)
            genQasmLabel(strFuncEndLabel, 'end of ' + fun.name)

            // genQasmComment('end of ' + fun.name)
            return newMap.get("return")
        }
        else if (fun.p) {           // an opaque operation
            // for opaque operation, generate the corresponding eQASM instructions.

            var opaque_type = fetchConfig(fun.name, "type")
            if (opaque_type.equals("init")) {
		        val OpDuration = fetchConfig(fun.name, "duration") as Integer
		        genInsnWait(OpDuration)
            } 
            else if (opaque_type.equals("meas")) { // measure
                var MsmtEqasmName = fetchConfig(fun.name, "eqasm") as String
                var regQotrs      = pars.get(0).compile(map).reg
                var iMsmtDuration = fetchConfig(fun.name, "duration") as Integer
                var meta = genInsnForMsmt(MsmtEqasmName, regQotrs, iMsmtDuration)
                genQasmComment('end of ' + fun.name)
                return meta
            } 
            else if (opaque_type.equals("single-qubit")) { // single qubit operations such as H
                val PreInterval = duration
                val opName = fetchConfig(fun.name, "eqasm") as String
                val regQotrs = pars.get(0).compile(map).reg
                genInsnSQOperation(PreInterval, opName, regQotrs)
                duration = fetchConfig(fun.name, "duration") as Integer
            } 
            else if (opaque_type.equals("single-qubit-param")) { // single qubit operations with an additional
                                                                 // double parameter, such as X(q, 180)
                var PreInterval = duration
                var pmeta = pars.get(1).compile(map)
                if (!pmeta.valid.constant) {
                    throw new IOException("[_compileFunctionCall] only constant double numbers are supported now!"
                        + " Check line " + node.startLine + "\n"
                    )
                }

                var opName = fetchConfig(fun.name, "eqasm") as String
                var param = pmeta.value as Float
                var finalOpName = genOpNameWithParam(opName, param)
                val regQotrs = pars.get(0).compile(map).reg
                genInsnSQOperation(PreInterval, finalOpName, regQotrs)
                duration = fetchConfig(fun.name, "duration") as Integer
            } 
            else if (opaque_type.equals("two-qubit")) { // two-qubit operations, such as CZ(q1, q2)
                var q0 = pars.get(0).compile(map).reg.substring(1)
                var q1 = pars.get(1).compile(map).reg.substring(1)

                val PreInterval = duration
                val opName = fetchConfig(fun.name, "eqasm") as String
                val qubit_pair = new QubitPair(intFromString(q0), intFromString(q1))
                genInsnTQOperation(PreInterval, opName, qubit_pair)
                duration = fetchConfig(fun.name, "duration") as Integer
            } 
            else {
	            throw new UnsupportedOperationException("Error, unrecognized opaque type: " + opaque_type)
            }
            global += fetchConfig(fun.name, "duration") as Integer
        } 
        else {
            throw new UnsupportedOperationException("Error, the function type of " + fun.name + "is neither 'operation' nor 'opaque'.")
        }
        genQasmComment('end of ' + fun.name)
        return null
    }

    /**
     * Compile the left side of an assignment statement.
     * 
     * @param leftExp  the Expression on the left side of an assignment statement
     * @param map      the symbol table of the parent operation
     * @return         the compiled MetaData
     */
    def compileLeftHandSideExpression(Expression leftExp, HashMap<String, MetaData> map) {
        bExprOnLeftSide = true
        var metaLeftSide = leftExp.compile(map)
        bExprOnLeftSide = false
        return metaLeftSide
    }

    /**
     * Compile binary operators, i.e., add, sub, mul, div, rem
	 * <p>
	 * When the operands are both constant, the result is calculated during compilation time.
	 * Otherwise, an eQASM instruction is generated.
     * 
     * @param lmeta  the compiled left operand
     * @param rmeta  the compiled right operand
     * @param op     the operator
     * @return       the compilation result
     */
    def MetaData compileOperator(MetaData lmeta, MetaData rmeta, String op) {
        if (lmeta.valid.constant && rmeta.valid.constant) { // constant propagation
            if (lmeta.type instanceof IntType) {            // integer operations
                var lvalue = lmeta.value as Integer
                var rvalue = rmeta.value as Integer
                switch (op) {
                    case "+": return new MetaData(lvalue + rvalue)
                    case "-": return new MetaData(lvalue - rvalue)
                    case "*": return new MetaData(lvalue * rvalue)
                    case "/": return new MetaData(lvalue / rvalue)
                    case "%": return new MetaData(lvalue % rvalue)
                }
            }
            else {                                          // floating-point operations
                var lvalue = lmeta.value as Float
                var rvalue = rmeta.value as Float
                switch (op) {
                    case "+": return new MetaData(lvalue + rvalue)
                    case "-": return new MetaData(lvalue - rvalue)
                    case "*": return new MetaData(lvalue * rvalue)
                    case "/": return new MetaData(lvalue / rvalue)
                }
            }
        }

		// either operand is not constant
        var lreg = lmeta.register
        var rreg = rmeta.register
        var meta = allocMetaAndStackForType(lmeta.type)
        var reg = meta.register
        if (lmeta.type instanceof DoubleType) {
            Assertions.assertTrue(rmeta.type instanceof DoubleType)
            genInsnForFpArith(reg, lreg, op, rreg)
        } 
        else { // lmeta.type instanceof IntType
            genInsnForArith(reg, lreg, op, rreg)
        }
        return meta
    }

    // ----------------------------------------------------------------------------------
    // start of resource management
    // ----------------------------------------------------------------------------------

    /**
     * Allocate a qubit or an array of qubits.
     * 
     * @param name  variable name
     * @param type  variable's type. Only `qubit` or `qubit[]` are allowed
     * @param map   the symbol table of current operation
     * @return      the MetaData representing the allocated qubit(s)
     */
    def MetaData allocateQubit(String name, Type type, HashMap<String, MetaData> map) {
        var meta = new MetaData
        if (type instanceof QubitType) {
            meta.reg = "s" + sIndex
            var Integer[] qArray = #{sIndex++}
            genInsnSetQotrs(meta.reg, qArray)
        } 
        else { // type is qubit[]
            var atype = type as ArrayType
            if (atype.length === null) {
                meta.value = 0
            } 
            else { //atype.length !== null
                var metaLength = atype.length.compile(map)
                if (!metaLength.valid.constant) {
                    writeInsnToFile
                    throw new IOException("[allocateQubit] The length of qubit array must be constant!\n")
                }
                meta.value = metaLength.value
            }

            meta.valid.constant = true
            meta.link = new ArrayList<MetaData>

            // allocate each qubit
            for (var i = 0; i < meta.value as Integer; i++) {
                var child = new MetaData
                child.reg = "s" + sIndex
                var Integer[] qArray = #{sIndex++}
                genInsnSetQotrs(child.reg, qArray)
                meta.link.add(child)
            }
        }

        meta.type = QuingoQubitType
        map.put(name, meta)
        return meta
    }

    /**
     * Get a free GPR which is not bound to any meta data.
     * <p>
     * NOTE: there is a risk that this function falls into the dead loop during operations regarding a
     * very-high-dimension array.
     * 
     * @return  the name of the allocated register
     */
    def String getFreeGpr() {
        var reg = getNewPollingGprIndx()
        while (mapRegToMetadata.get(reg) !== null) {
            reg = getNewPollingGprIndx()
        }
        return reg
    }

    /**
     * Get a new general purpose register.
     * 
     * @return  the name of the allocated register
     */
    def String allocRegister() {
        allocRegister(QuingoIntType)
    }

    /**
     * Allocate a register to store a variable of the specified type.
     * <p>
     * If this register has been used by another variable, the value of the old variable
     * is stored to memory first.
     * 
     * @param type  the type of value that will be stored in the register
     * @return      the name of the allocated register
     */
    def String allocRegister(Type type) {
        var String reg = ''
        if (type instanceof DoubleType) {
            reg = getNewPollingFprIdx()
        } 
        else { // type instanceof IntType
            reg = getNewPollingGprIndx()
        }

        var meta = mapRegToMetadata.get(reg)  // get the possibly bound meta data
        if (meta !== null) {            // if the register is already bound to a meta data
            decoupleRegFromMeta(meta)
        }
        return reg
    }

    /**
     * Vacate the register associated with the given metadata, so the register can be used for other purposes.
     * 
     * @param metadata  the MetaData containing the register
     * @return          null
     */
    def decoupleRegFromMeta(MetaData metadata) {
        var valid = metadata.valid
        if (valid.onlyReg) {        //store reg to memory
            ensureHasStackMemory(metadata)
            storeRegToMem(metadata.type, metadata.reg, metadata.address)
            valid.setOnlyMem
        }
        metadata.reg = ""
        valid.reg = false
    }

    /**
     * Allocate an F register.
     * <p>
     * f0 is used for a special purpose (representing 0) and cannot be allocated.
     * 
     * @return  the name of the allocated register
     */
    def String getNewPollingFprIdx() {
        if (fIndex > 31) {
            fIndex = 1
        }
        return "f" + fIndex++
    }

    /**
     * Allocate an general purpose register. 
     * <p>
     * r0, r1, and r2 are used for special purposes and cannot be allocated.
     * 
     * @return  the name of the allocated register
     */
    def String getNewPollingGprIndx() {
        if (iIndex > 31) {
            iIndex = 3
        }
        return "r" + iIndex++
    }

    /**
     * Allocate memory for a MetaData if it has not been allocated.
     * 
     * @param meta  The to be examined MetaData
     * @return      null
     */
    def ensureHasStackMemory(MetaData meta) {
        if (meta.address === 0) {
            meta.address = allocStackMemory(meta.type)
        }
    }

    /** 
     * Allocate a register for a variable with give name and type.
     * <p>
     * It consists of the following steps: 1. create a metaData with required stack space for 
     * this variable (allocMetaAndStackForType); 2. allocate required heap space for this 
     * variable (createMetaData)
     * 
     * @param strVarName the name of this variable
     * @param typeVar    the type of this variable
     * @param map        the symbol table while performing register allocation for this variable
     * @return           allocated MetaData
     */
    def MetaData allocRegForVariable(String strVarName, Type typeVariable,
                                     HashMap<String, MetaData> map) {
        var metaVariable = allocMetaAndStackForType(typeVariable)
        createMetaData(metaVariable, typeVariable, map)

        if (xsemantics.isQubitTypes(typeVariable) || typeVariable instanceof FunctionType) {
            metaVariable.type = QuingoQubitType
        }
        map.put(strVarName, metaVariable)
        return metaVariable
    }

    /**
     * Create a MetaData with an associated stack space for a type.
     * <p>
     * NOTE: the metaData created is superficial, i.e., the link field is still empty. In other words,
     * no other meta data has been created for elements of the type if this type is an array or tuple.
     * 
     * @param type  the specified type
     * @return      created MetaData
     */
    def MetaData allocMetaAndStackForType(Type type) {
        var metaCreated = new MetaData
        metaCreated.type = copyQuingoType(type)
        metaCreated.address = allocStackMemory(type)
        return metaCreated
    }

    /**
     * Allocate heap space for array members.
     *
     * @param metaArray  the array metaData, which is operated by this function
     * @param type       the actual type to allocate memory for
     * @param map        the symbol table of current operation
     */
    def void createMetaData(MetaData metaArray, Type _type, HashMap<String, MetaData> map) {
        if (!(_type instanceof ArrayType)) { return }  // only ArrayType needs heap allocation

        var type = _type as ArrayType
        var exprArrLength  = type.length
        var typeArrElement = type.ptype
        var const = true  // whether the memory can be allocated during compilation time

		/* 
		 * Reconstruct multi-dimensional array type's length. E.g., int[2][3] means the inner array
		 * is of size 2 and the outer array is of size 3. However, its AST structure is not convenient
		 * to use for recursion. Here, we change it to ArrayType(ArrayType(int, 3), 2).
		 */ 
        while (typeArrElement instanceof ArrayType) {    // recursively handle multi-dimension array
            var iSubArrLength = typeArrElement.length
            if (iSubArrLength !== null) {
                // try to retrieve the length of the subarray
                var metaSubArrLength = iSubArrLength.compile(map)

                // if the length of the subarray is known, but it is too large, we still refuse to
                // allocate the heap space during compilation
                if (metaSubArrLength.valid.constant && 
                	convToInt(metaSubArrLength.value) >= Configuration.maxUnrolling) {
                    const = false
                }
            }

            // recursion
            typeArrElement.setLength(exprArrLength)
            exprArrLength  = iSubArrLength
            typeArrElement = typeArrElement.ptype
        }

        /**
         * Rationale of storing memoryAddr to `regArrayHead`:
         *  - When the space for the array is allocated in the function `allocMetaAndStackForType`, only the
         *    space for a pointer is allocated. No space is allocated for the array body yet.
         *  - Now, we are going to allocate the space for the array body. In the following
         *    implementation, the array body is assumed to start at memoryAddr. In other words,
         *    the array body is put on the top of the stack.
         *  - The array register stores the array head, which is the pointer to the array body,
         *    which is in turn memoryAddr.
         */
        var regArrayHead = metaArray.register
        loadImmToReg(strToGPR(regArrayHead), memoryAddr)

        var iArrLength = 0
        if (exprArrLength !== null) {

            // Decide the length of the array
            var metaArrLength = exprArrLength.compile(map)

            // if the length is a static value, retrieve it.
            if (metaArrLength.valid.constant) {
                iArrLength = convToInt(metaArrLength.value)
            }

            if (iArrLength >= Configuration.maxUnrolling ||
                  (metaArray.value instanceof Integer && (metaArray.value as Integer) < 0)) {
                const = false
                metaArray.valid.setOnlyReg

                // Allocate a heap space to store the array length
                // note: regArrayHead now points to the heap address
                loadHeapPtrToReg(regArrayHead)

                // store the length (metaArrLength) to the heap head (i.e., the array body)
                var regArrLength = metaArrLength.register
                storeRegToMem(regArrLength, 0, regArrayHead)

                /* Allocate heap space for the array body, as a consquence, the heap pointer
                   will be shifted by `INT_SIZE + NumOfElements * NumOfBytesPerElement`  */
                allocHeapForArrayBody(type.ptype, metaArrLength)

                if (type.ptype instanceof ArrayType) {
                    // Set initial values
                    var regEleArrHeadAddr = allocRegister
                    // regEleArrHeadAddr <- content[regArrayHead] + INT_SIZE
                    genInsnAddConst(regEleArrHeadAddr, regArrayHead, Serializer.INT_SIZE)

                    var regIndex = allocRegister
                    genInsnResetRegToZero(regIndex)            // regIndex = 0

                    var iArrLabelIndex   = arrayIndex++
                    var strArrStartLabel = genArrStartLabel(iArrLabelIndex)
                    var strArrEndLabel   = genArrEndLabel(iArrLabelIndex)

                     /* The following loop performs this task:
                     i = 0;
                     while(i < ArrLength) {
                         create MetaData for the i-th sub-array
                         store the address of the body of the i-th sub-array to the i-th cell of the current array
                     } */
                    // while head: while (i < ArrLength)
                    genQasmLabel(strArrStartLabel)
                    regArrLength = metaArrLength.register
                    genInsnGotoLabelUponCmp(regIndex, '>', regArrLength, strArrEndLabel)

                    // while body: allocate recursively {
                    var metaSubArray   = allocMetaAndStackForType(type.ptype)
                    metaSubArray.value = -1
                    createMetaData(metaSubArray, type.ptype, map)

			        // store the array body's pointer to the address stored in the `regEleArrHeadAddr`
			        storeRegToMem(metaSubArray.register, 0, regEleArrHeadAddr)
                    // } end of loop body

                    // while tail: increase the index
                    genInsnAddConst(regEleArrHeadAddr, Serializer.POINTER_SIZE)
                    genInsnAddConst(regIndex, 1)
                    insertQasmGoto(strArrStartLabel)
                    genQasmLabel(strArrEndLabel)    // loop end
                }
            }
        }

        if (const) {
            metaArray.valid.setConAndReg
            metaArray.value = iArrLength

            // Allocate memory for the array
            var iNumOfBytesPerElement = dataSize(typeArrElement)
            var iBodyAddr             = allocStackForArrayBody(typeArrElement, iArrLength)

            // Create array members
            var iElementAddr = iBodyAddr + Serializer.INT_SIZE
            metaArray.link = new ArrayList<MetaData>
            for (var i = 0; i < iArrLength; i++) {
                var metaElement     = allocMetaAndStackForType(type.ptype)
                metaElement.address = iElementAddr
                iElementAddr       += iNumOfBytesPerElement
                createMetaData(metaElement, type.ptype, map)
                metaArray.link.add(metaElement)
            }
        }

        // Restore the original type
        var atype = typeArrElement.eContainer as ArrayType
        while (atype !== type) {
            var temp = atype.length
            atype.setLength(exprArrLength)
            exprArrLength = temp
            atype = atype.eContainer as ArrayType
        }
        type.setLength(exprArrLength)
    }

    /**
     * Shift the heap pointer by an integer.
     *
     * @param iNumOfBytes  the number of bytes to shift
     * @return             null
     */
    def shiftHeapPtr(int iNumOfBytes) {
        genInsnAddConst('r2', 'r2', iNumOfBytes)
    }

    /**
     * Shift the heap pointer by the value in a register.
     *
     * @param regNumOfBytes  the register storing the shifting amount
     * @return               null
     */
    def shiftHeapPtr(String regNumOfBytes) {
        genInsnAddRegs('r2', 'r2', regNumOfBytes)
    }

    /**
     * Allocate a piece of heap space to store an array body
     * <p>
     * The structure of an array is: `[ length(=n), ele_0, ele_1, ele_2, ..., ele_{n-1} ]`.
     * This operation shifts the heap pointer by {@code NumOfBytes = INT_SIZE + NumOfElements * NumOfBytesPerElement}
     * where the extra {@code INT_SIZE} is used to store the length of the array.
     *
     * @param typeElement        the type of the element
     * @param metaNumOfElements  the MetaData storing the array length
     */
    def void allocHeapForArrayBody(Type typeElement, MetaData metaNumOfElements) {
        var iSizeOfType = dataSize(typeElement)

        if (metaNumOfElements.valid.constant) {  // NumOfBytes is statically known
            var iNumOfElements = convToInt(metaNumOfElements.value)
            var iNumOfBytes = iNumOfElements * iSizeOfType + Serializer.INT_SIZE
            shiftHeapPtr(iNumOfBytes)
        } 
        else {                                // NumOfBytes is not statically known
            var regNumOfBytes = allocRegister
            var regNumOfElements = metaNumOfElements.register
            genInsnForMAC(regNumOfBytes, regNumOfElements, iSizeOfType, Serializer.INT_SIZE)
            shiftHeapPtr(regNumOfBytes)
        }
    }

    /**
     * Allocate stack for the body of an array
     *
     * @param typeElement  the type of the element
     * @param iArrLength   the length of the array
     * @return             the address of the allocated space
     */
    def int allocStackForArrayBody(Type typeElement, int iArrLength) {
        var iStartAddr = memoryAddr
        memoryAddr += Serializer.INT_SIZE + iArrLength * dataSize(typeElement)
        return iStartAddr
    }

    /**
     * Allocate stack for a primitive type
     *
     * @param type  the type of the variable
     * @return      the address of the allocated space
     */
    def allocStackMemory(Type type) {
        var iStartAddrForVar = memoryAddr
        memoryAddr += dataSize(type)
        return iStartAddrForVar
    }

    // ----------------------------------------------------------------------------------
    // end of resource management
    // ----------------------------------------------------------------------------------

    // ----------------------------------------------------------------------------------
    // start of meta data utilities
    // ----------------------------------------------------------------------------------
    /** 
     * Assign the value of a MetaData to another.
     * <p>
     * This function is the implementation of assignment. It handles all the data types.
     * 
     * @param metaTarget  MetaData of the target, or left-hand side of this assignment
     * @param metaSource  meta data of the source, or right-hand side of this assignment
     * @param type        the concrete type of date on both sides of the assignment
     * @param node        the concrete AST node to process, which is used to emit error message.
     */
    def void assignMetaData(MetaData metaTarget, MetaData metaSource, Type type, ICompositeNode node) {
        if (type instanceof TupleType) {
            var elementTypes = (type as TupleType).type         // the list of element types
            var linkIsNull = metaTarget.link === null

            if (linkIsNull) {
                metaTarget.link = new ArrayList<MetaData>
            }
            ensureHasStackMemory(metaTarget)
            var iTargetAddr = metaTarget.address              // the stack address of the target

            for (var i = 0; i < elementTypes.length; i++) {     // get each element in the tuple
                var metaSrcElement = metaSource.link.get(i)
                var typeElement = elementTypes.get(i)

                var MetaData metaElement
                if (linkIsNull) {                               // allocate metaData for the element
                    metaElement = allocMetaAndStackForType(typeElement)
                    createMetaData(metaElement, typeElement, null)
                    metaElement.address = iTargetAddr
                    iTargetAddr        += typeElement.dataSize
                    metaTarget.link.add(metaElement)
                } 
                else { // metaTarget.link !== null
                    metaElement = metaTarget.link.get(i)
                }

                // recursively assign MetaData
                assignMetaData(metaElement, metaSrcElement, typeElement, node)
            }
            metaTarget.valid.setOnlyConstant           // the newest value is only stored in MetaData
        } 
        else if (type instanceof ArrayType) {
            var typeArrElement = getArrayElementType(type)
            if (metaTarget.valid.constant && metaSource.valid.constant) { // elements are stored in MetaData
                var iArrLength = convToInt(metaSource.value)

                /* if the target meta data have not yet allocate element space, or
                 * it does not have enough space to allocate all elements in the source meta data,
                 * allocate a new `MetaData` list for the source elements.
                 *
                 * N.B. the new block is directly put at memoryAddr, and the possible original meta
                 * data in the target meta data is thrown away.
                 */
                if ((metaTarget.link === null) || (metaTarget.value as Integer) < iArrLength) {
                    var reg = metaTarget.register
                    metaTarget.value = iArrLength

                    // the space is allocated from heap, which is indicated by memoryAddr
                    loadImmToReg(strToGPR(reg), memoryAddr)

                    // Allocate memory for the array
                    var addr = memoryAddr + Serializer.INT_SIZE
                    var size = dataSize(typeArrElement)

                    // Increase the heap pointer
                    memoryAddr = addr + iArrLength * size

                    // Create a `MetaData` list to store the array elements
                    metaTarget.link = new ArrayList<MetaData>

                    for (sourceElementMeta : metaSource.link) {
                        // We still need to allocated memory space for the element because it
                        // may also need to be stored in the memory
                        var elementMeta = allocMetaAndStackForType(typeArrElement)
                        createMetaData(elementMeta, typeArrElement, null)
                        elementMeta.address = addr
                        addr += size

                        assignMetaData(elementMeta, sourceElementMeta, typeArrElement, node)
                        metaTarget.link.add(elementMeta)    // append this MetaData
                    }
                } 
                else { // no need for allocating MetaData
                
                    // target[0:iArrLength] = src[0:iArrLength]
                    for (var i = 0; i < iArrLength; i++) {
                        assignMetaData(metaTarget.link.get(i), metaSource.link.get(i),
                                       typeArrElement, node)
                    }
                    var numberOfExtraMetaData = (metaTarget.value as Integer) - iArrLength

                    // remove target[iArrLength:-1]
                    for (var i = 0; i < numberOfExtraMetaData; i++) {
                        metaTarget.link.remove(iArrLength)
                    }
                    metaTarget.value = metaSource.value     // update the target array length
                }
                metaTarget.valid.constant = true
            } 
            else {    // elements are not stored in MetaData

                // write back all registers to memory at first
                flushAllRegsToMem()

                metaTarget.storeToMem           // write the data in the target back to memory
                metaSource.storeToMem           // write the data in the source back to memory

                // create a new meta data with the same type as the target meta data
                var metaTmpTarget = allocMetaAndStackForType(metaTarget.type)
                var regTmpTarget = metaTmpTarget.register

                // load target meta data address to `regTmpTarget`
                loadImmToReg(strToGPR(regTmpTarget), metaTarget.address)

                // create a new meta data with the same type as the source meta data
                var metaTmpSource = allocMetaAndStackForType(metaSource.type)
                var regTmpSource = metaTmpSource.register

                // load source meta data address to `regTmpSource`
                loadImmToReg(strToGPR(regTmpSource), metaSource.address)

                assignDataInMem(metaTmpTarget, metaTmpSource)
                metaTarget.valid.setOnlyMem
            }
        } 
        else if (type instanceof QubitType || type instanceof FunctionType) {
            metaTarget.reg = metaSource.reg
        }
        else if (metaTarget.type instanceof PointerType) {
            // NOTE: this is not a process copying the pointer.
            // Instead, it stores the content in the regSource to the memory location pointed to by regTarget
            var regSource = metaSource.register
            var regTarget = metaTarget.register
            var iOffset = metaTarget.value as Integer
            storeRegToMem(metaSource.type, regSource, iOffset, regTarget)
            metaTarget.valid.setOnlyReg
        }
        else { // Assignment for primitive types
            if (metaSource.valid.constant) {        // the newest value is in the MetaData
                metaTarget.valid.setOnlyConstant
                metaTarget.value = metaSource.value
                metaTarget.type  = copyQuingoType(metaSource.type)
                return
            } 
            else if (metaSource.valid.mem) {      // the newest value is in the memory
                metaSource.register               // load the value into the register.
            }
            // No need for an `else` branch because metaSource.valid.reg is handled next.

            if (metaSource.valid.reg) {             // register has the newest value
                var regTarget = metaTarget.register
                var regSource = metaSource.register
                if (metaSource.type instanceof DoubleType) {
                    genInsnFpAddRegs(regTarget, regSource, 'f0')
                } 
                else { // metaSource.type instanceof IntType or BoolType
                    genInsnMovReg(regTarget, regSource)
                }
                metaTarget.type = copyQuingoType(metaSource.type)
                metaTarget.valid.setOnlyReg
            }
            else { // this should not happen because it means that metaSource is not valid
                writeInsnToFile
                throw new IOException("[assignMetaData] undefined source value in line " + node.startLine + "!\n")
            }
        }
    }

    /**
     * Assignment of an array that is stored in the memory.
     * 
     * @param metaTgtData  the MetaData of the target
     * @param metaSrcData  the MeteData of the source
     */
    def void assignDataInMem(MetaData metaTgtData, MetaData metaSrcData) {

		// head address of the source/target data in the memory
        var regTgtDataAddr = metaTgtData.register
        var regSrcDataAddr = metaSrcData.register

        var type = metaTgtData.type
        if (type instanceof ArrayType) {

            // load the pointer to the target array body to the `regTgtArrayBodyAddr` register
            var regTgtArrayBodyAddr = allocRegister
            loadMemToReg(type, regTgtArrayBodyAddr, 0, regTgtDataAddr)

            // load the pointer to the source array body to the `regSrcArrayBodyAddr` register
            var regSrcArrayBodyAddr = allocRegister
            loadMemToReg(type, regSrcArrayBodyAddr, 0, regSrcDataAddr)

            // Compare the length
            var metaSrcArrayLength = allocMetaAndStackForType(QuingoIntType)
            var regSrcArrayLength  = metaSrcArrayLength.register

            // load the source array length to `regSrcArrayLength`
            loadMemToReg(type, regSrcArrayLength, 0, regSrcArrayBodyAddr)

            var metaTgtArrayLength = allocMetaAndStackForType(QuingoIntType)
            var regTgtArrayLength  = metaTgtArrayLength.register

            // load the target array length to `regTgtArrayLength`
            loadMemToReg(type, regTgtArrayLength, 0, regTgtArrayBodyAddr)


            var k = arrayIndex++
            var ArrayAllocLabel = "ARRAY_ALLOC_" + k + "_END"

            /** compare source array length and target array length */
            genInsnGotoLabelUponCmp(regSrcArrayLength, '<=', regTgtArrayLength, ArrayAllocLabel)

            /** Start of action region if src_array_length > target_array_length
             *
             * Locate the target array body at the top of the heap.
             *  - This is done by putting the heap head (r2) to regTgtArrayBodyAddr.
             */
             loadHeapPtrToReg(regTgtArrayBodyAddr)

            // The array head points to the array body (the heap top)
            storeRegToMem('r2', 0, regTgtDataAddr)
            allocHeapForArrayBody(type.ptype, metaSrcArrayLength)
            /** N.B. this is not the end of action region if src_array_length > target_array_length
             *  The following instructions are the following actions.
             */


            /** Now, we are sure that the target array has enough space to contain all elements
             * in the source array.
             */
            genQasmLabel(ArrayAllocLabel)

            // replace the old target array length with the source array length
            storeRegToMem(regSrcArrayLength, 0, regTgtArrayBodyAddr)

            /** The first element of the array is stored after the length in the body, i.e.
             *   `ele_addr = body_addr + INT_SIZE [= size(length)]`
             */
            var metaSrcElement = allocMetaAndStackForType(type.ptype)       // for the source
            var regSrcElementAddr = metaSrcElement.register

            genInsnAddConst(regSrcElementAddr, regSrcArrayBodyAddr, Serializer.INT_SIZE)

            var metaTgtElement = allocMetaAndStackForType(type.ptype)       // for the target
            var regTgtElementAddr = metaTgtElement.register
            genInsnAddConst(regTgtElementAddr, regTgtArrayBodyAddr, Serializer.INT_SIZE)


            // allocate an internal variable serving as the index to iterate over the array
            var metaIndex = allocMetaAndStackForType(QuingoIntType)
            var regIndex = metaIndex.register
            genInsnResetRegToZero(regIndex)


            // while (regIndex < regSrcArrayLength) do:
            var labelArrayLoopStart = genArrStartLabel(k)    // "ARRAY_" + k
            var labelArrayLoopEnd   = genArrEndLabel(k) // "ARRAY_" + k + "_end"
            genQasmLabel(labelArrayLoopStart)

            // compare index and src_array_length
            // exit the loop when !(index < src_array_length)
            genInsnGotoLabelUponCmp(regIndex, '>=', regSrcArrayLength, labelArrayLoopEnd)

            // recursively assign data in memory
            assignDataInMem(metaTgtElement, metaSrcElement)

            // update the index
            regIndex = metaIndex.register
            genInsnAddConst(regIndex, 1)
            // unconditionally jump back to the loop start after one iteration
            insertQasmGoto(labelArrayLoopStart)
            // end while (regIndex < regSrcArrayLength)

            // add loop exit label
            genQasmLabel(labelArrayLoopEnd)
        } 
        else {    // primitive values
            var regValue = allocRegister(type)

            // load the value to the `regValue` register
            loadMemToReg(type, regValue, 0, regSrcDataAddr)

            // store value in `regValue` register to the target address
            storeRegToMem(type, regValue, 0, regTgtDataAddr)
        }

        // Advance the pointers
        var iNumOfBytes = dataSize(type)
        genInsnAddConst(regSrcDataAddr, iNumOfBytes)
        genInsnAddConst(regTgtDataAddr, iNumOfBytes)
    }

    /**
     * Store all the variables in memory.
     * 
     * @param map  symbol table of current operation
     * @return     null
     */
    def storeToMem(HashMap<String, MetaData> map) {
        genQasmComment('Start storing all variables to the memory')
        for (meta: map.values) {
            if (!(meta.type instanceof QubitType) && meta.valid.atLeastOne) {
                meta.storeToMem
            }
        }
        genQasmComment('Finished storing all variables to the memory')
    }

    /**
     * Store a variable in memory.
     * 
     * @param strVarName  the name of the variable
     * @param map         symbol table of current operation
     * @param onlyMem     whether to disable values in MetaData (constant) or the memory (reg)
     * @return            null
     */
    def storeToMem(String strVarName, HashMap<String, MetaData> map, Boolean onlyMem) {
        map.get(strVarName)?.storeToMem(onlyMem)
    }

    /**
     * Store a variable in memory.
     * 
     * @param meta  the MetaData of the variable
     */
    def void storeToMem(MetaData meta) {
    	meta.storeToMem(true)
    }
    
    /**
     * Store a variable in memory.
     * 
     * @param meta     the MetaData of the variable
     * @param onlyMem  whether to disable values in MetaData (constant) or the memory (reg)
     */
    def void storeToMem(MetaData meta, Boolean onlyMem) {
        var link = meta.link
        var valid = meta.valid

		// skip qubit type
        if (meta.type instanceof QubitType) { 
        	return
        }

        if (meta.valid.mem) {                           // data is already in the memory, skip
            valid.setOnlyMem
            return
        }

        ensureHasStackMemory(meta)
        var iDataStackAddr = meta.address            // get the address field in the meta data

        if (valid.constant) {           // this is a static node
            /* The value of this variable is stored in the corresponding meta data
             * To store this value into the memory, two steps are required:
             *  1. load the value into a register;
             *  2. upload the value from the register to the corresponding memory position.
             */
            if (meta.type instanceof TupleType) {

                // store each element in the tuple to the memory
                for (metaTupleElement : link) { 
                	metaTupleElement.storeToMem
                }
            } 
            else if (meta.type instanceof ArrayType) {

                // load the length of the array (immediate value) into the register regArrLength
                var regArrLength = allocRegister()
                loadImmToReg(strToGPR(regArrLength), meta.value as Integer,
                            'Load the array length to the register')

                var regArrayHead = meta.reg
                if (regArrayHead == "") {
                    regArrayHead = allocRegister()
                    
                    // Load the address of the array to the register `regArrayHead`
			        var insn = loadMemToReg(regArrayHead, meta.address)
			        insn.setTrailingComment('load array body pointer')
                }

		        /**
		         * Store the array length to memory.
		         * mem_content[reg_content[`regArrayHead`]] = length of the array, i.e.,
		         *     mem_content[pointer to array body] = length of the array
		         */
		        var insn = storeRegToMem(regArrLength, 0, regArrayHead)
		        insn.setTrailingComment('write the array length to memory.')

                // Store `regArrayHead` register (pointer to the array body) to the array stack address
		        insn = storeRegToMem(regArrayHead, meta.address)
		        insn.setTrailingComment('write the array head to memory.')

                // store each element of the array into memory recursively.
                for (metaArrElement : link) {
                    metaArrElement.storeToMem
                }

                meta.link = null      // clear the link
                meta.reg  = ""
            } 
            else if (meta.type instanceof BoolType) {
                var regValue = meta.value as Boolean? "r1": "r0"
                storeRegToMem(meta.type, regValue, iDataStackAddr)
            } 
            else if (meta.type instanceof DoubleType) {
                var regValue = allocRegister

                // Load the immediate float value (as binary bits) into the `regValue` register.
                loadImmToReg(strToGPR(regValue), Float.floatToIntBits(meta.value as Float))

                // Store the value into the corresponding memory.
                storeRegToMem(regValue, iDataStackAddr)
            } 
            else {  // meta.type instanceof IntType
                var regValue = allocRegister(meta.type)

                // Load the immediate int or float value into the `regValue` register.
                loadImmToReg(strToGPR(regValue), meta.value as Integer)

                // Store the value into the corresponding memory.
                storeRegToMem(meta.type, regValue, iDataStackAddr)
            }
        } 
        else if (valid.reg) {         // this is a dynamic node
            /* The value of this variable is stored in the register.
             * Only one step is required to store this value into memory:
             *  - directly upload the value from the register to the corresponding memory position.
             */
             storeRegToMem(meta.type, meta.reg, iDataStackAddr)
        }

        // after all data is stored to the memory, modify the `valid` label accordingly.
        if (onlyMem) {
	        valid.setOnlyMem
        }
    }

    /**
     * Get the associated register of the given metadata, and ensure the register contains the newest data.
     * <p>
     * If this metaData does not have an associated register yet, this function creates a new one.
     * <p>
     * The function loads the value to the register to ensure it has the newest value.
     * 
     * @param meta  input MetaData
     * @return      the name of the register
     */
    def String getRegister(MetaData meta) {
        var valid = meta.valid

        if (valid.reg) {        // the associated register has the newest value for the variable
            return meta.reg     // return the associated register `reg`
        }

        if (meta.reg.equals("")) {          // no associated register yet, allocate one.
            meta.reg = allocRegister(meta.type)
        }

        val type = meta.type
        if (valid.constant) {
            /** if the meta data has the newest value, load the value to the associated register */
            if (type instanceof BoolType) {            // bool
                var src = (meta.value as Boolean)? "r1": "r0"
                genInsnMovReg(meta.reg, src)
            } 
            else if (type instanceof DoubleType) {   // float
                var regTempTransfer = allocRegister
                loadFpImmToReg(meta.reg, meta.value as Float, regTempTransfer)
            } 
            else if (type instanceof ArrayType) {    // array
                loadMemToReg(meta.reg, meta.address)
            } 
            else {                                        // tuple, int
                loadImmToReg(strToGPR(meta.reg), meta.value as Integer)
            }
        } 
        else if (valid.mem) {
            loadMemToReg(type, meta.reg, meta.address)
        } 

        valid.reg = true
        mapRegToMetadata.put(meta.reg, meta)

        return meta.reg
    }

    // ----------------------------------------------------------------------------------
    // end of meta data utilities
    // ----------------------------------------------------------------------------------

    // ----------------------------------------------------------------------------------
    // start of serialization
    // ----------------------------------------------------------------------------------

    /**
     * Serialize data and put it in the shared memory.
     * 
     * @param metaMockStackPtr  the pointer to the stack head
     * @param metaHeapPtr       the pointer to the heap head, from which point on, the memory space
     *                          is free and can be used to locate data.
     * @param metaDataToExport  the MetaData to be exported
     * @param type              the data type of the exported data
     */
    def void exportMetaData(MetaData metaMockStackPtr, MetaData metaMockHeapPtr,
                            MetaData metaDataToExport, Type type) {

        var strType = convTypeToStr(type)
        genQasmComment("start exporting: " + strType)

        var iMockStackPtr = convToInt(metaMockStackPtr.value)
        var iMockHeapPtr  = convToInt(metaMockHeapPtr.value)

        // the heap data should be stored after both the stack and previously-used heap space.
        iMockHeapPtr          = Math.max(iMockHeapPtr, iMockStackPtr + dataSize(type))
        metaMockHeapPtr.value = iMockHeapPtr

        if (type instanceof TupleType) {

            // meta data for this tuple?
            var metaTmpStackPtr   = new MetaData
            metaTmpStackPtr.type  = new PointerType
            metaTmpStackPtr.value = metaMockStackPtr.value   // pointer offset
            var regTmpStackPtr    = metaTmpStackPtr.register

            /** valid.reg == true && valid.constant == false:
             * the final destination is offset + base address
             */
            metaTmpStackPtr.valid.setOnlyReg                  // pointer base address
            loadImmToReg(strToGPR(regTmpStackPtr), Configuration.sharedAddr,
                         'load sharedAddr to the base register: ' + regTmpStackPtr)

            var elementTypes = (type as TupleType).type
            for (var i = 0; i < elementTypes.length; i++) { // recursively export each element

                var curElementType     = elementTypes.get(i)
                var curElementTypeSize = dataSize(elementTypes.get(i))
                var curElement         = metaDataToExport.link.get(i)

				// recursively export the elements of the tuple
                exportMetaData(metaTmpStackPtr, metaMockHeapPtr, curElement, curElementType)

                // After one element is exported, it occupies the export stack space. Hence,
                //   the mock stack head should move forward.
                metaTmpStackPtr.value = convToInt(metaTmpStackPtr.value) + curElementTypeSize
            }
        }
        else if (type instanceof ArrayType) {

            var typeArrElement  = getArrayElementType(type)
            var iSizeArrElement = dataSize(typeArrElement)

            if (metaDataToExport.valid.constant) {  // the length of the array is known

                // Store the offset to the newly allocated register
                var regOffset = allocRegister
                var offset    = iMockHeapPtr - iMockStackPtr // = array body address - array pointer address
                loadImmToReg(strToGPR(regOffset), offset, "load offset (array body <-> head)")

                // The write address is iMockStackPtr + regStackPtr
                var regStackPtr = metaMockStackPtr.register
                var insn = storeRegToMem(regOffset, iMockStackPtr, regStackPtr)
                insn.setTrailingComment('Store array offset to memory address: regStackPtr + iMockStackPtr (' + iMockStackPtr + ')')

                // Store the length to the heap
                var length = metaDataToExport.value as Integer
                loadImmToReg(strToGPR(regOffset), length, 'store the array length (' + length + ') to the reg')

                insn = storeRegToMem(regOffset, iMockHeapPtr, regStackPtr)
                insn.setTrailingComment('Store the length to memory address: regStackPtr + iMockHeapPtr (' +
                                         iMockHeapPtr + ')')

                // update the tmp stack pointer for every element
                var metaTmpStackPtr   = new MetaData
                metaTmpStackPtr.type  = new PointerType
                metaTmpStackPtr.value = iMockHeapPtr + Serializer.INT_SIZE
                var regTmpStackPtr    = metaTmpStackPtr.register
                metaTmpStackPtr.valid.setOnlyReg

                loadImmToReg(strToGPR(regTmpStackPtr), Configuration.sharedAddr)

                metaMockHeapPtr.value = iMockHeapPtr + Serializer.INT_SIZE + length * iSizeArrElement

                for (member : metaDataToExport.link) {
                    exportMetaData(metaTmpStackPtr, metaMockHeapPtr, member, typeArrElement)
                    metaTmpStackPtr.value = (metaTmpStackPtr.value as Integer) + iSizeArrElement
                }
            } 
            else {                    // the length of the array is unknown during compilation

                // flush all registers by storing the data back into the correct memory space
                flushAllRegsToMem()
                mapRegToMetadata.clear

                genQasmComment('exporting array: ensure all variables to export are in the memory')
                metaDataToExport.storeToMem
                genQasmComment('exporting array: end of ensure all variables to export are in the memory')

                var regMockStackPtr = metaMockStackPtr.register

                var insn = genInsnAddConst(regMockStackPtr, iMockStackPtr)
                insn.setTrailingComment('update the mock stack ptr (' + regMockStackPtr + '): with an offset iMockStackPtr (' + iMockStackPtr + ')')

                var regMockHeapPtr = metaMockHeapPtr.register

                genInsnAddConst(regMockHeapPtr, iMockHeapPtr)
                insn.setTrailingComment('update the mock heap ptr (' + regMockHeapPtr + '): with an offset iMockHeapPtr (' + iMockHeapPtr + ')' )

                // Since the original meta data can distribute over the memory, a new meta data `metaExported` is
                // created to allocated for the exported data, which is aligned in the shared memory
                var metaExported = allocMetaAndStackForType(metaDataToExport.type)
                var regExported  = metaExported.register
                loadImmToReg(strToGPR(regExported), metaDataToExport.address)

                mapRegToMetadata.put(regMockStackPtr, metaMockStackPtr)
                mapRegToMetadata.put(regMockHeapPtr,  metaMockHeapPtr)
                mapRegToMetadata.put(regExported,     metaExported)
                exportMetaData(regMockStackPtr, regMockHeapPtr, regExported, type)

                // Remove the offset from the pointer register
                genInsnAddConst(regMockStackPtr, -convToInt(metaMockStackPtr.value))
                metaMockStackPtr.valid.setOnlyReg

                genInsnAddConst(regMockHeapPtr, -convToInt(metaMockHeapPtr.value))
                metaMockHeapPtr.valid.setOnlyReg
            }
        } 
        else if (type instanceof BoolType) {
            var String regBoolValue
            if (metaDataToExport.valid.constant) {      // r1, r0 are constantly 1 and 0, respectively.
                regBoolValue = (metaDataToExport.value as Boolean)? "r1": "r0"
            } 
            else {
                regBoolValue = metaDataToExport.register
            }

            storeRegToMem(type, regBoolValue, iMockStackPtr, metaMockStackPtr.register)
        } 
        else if (type instanceof DoubleType) {

            var regTempTransfer = allocRegister
            if (metaDataToExport.valid.constant) {
                loadImmToReg(strToGPR(regTempTransfer), Float.floatToIntBits(metaDataToExport.value as Float))
            } 
            else if (metaDataToExport.valid.reg) {
                var fregDataToExport = metaDataToExport.reg
                moveFprToGpr(regTempTransfer, fregDataToExport)
            } 
            else {
                loadMemToReg(type, regTempTransfer, metaDataToExport.address)
            }

            var regMockStackPtr = metaMockStackPtr.register
            /**
             * TODO: it is related to float-int conversion. Directly using the storeRegToMem function will lead to
             * a bug. Think about which instruction should be used later.
             * Now I have changed it. See this can work or not.
             */
            // storeRegToMem(type, regTempTransfer, iMockStackPtr, regMockStackPtr)
            storeRegToMem(regTempTransfer, iMockStackPtr, regMockStackPtr)
        } 
        else {
            var regDataToExport = metaDataToExport.register
            var regMockStackPtr = metaMockStackPtr.register
            storeRegToMem(type, regDataToExport, iMockStackPtr, regMockStackPtr)
        }
        genQasmComment("Finished exporting: " + strType)
    }

    /**
     * Serialize data (stored in memory) and put it in the shared memory.
     * 
     * @param regMockStackPtr  the pointer to the stack head
     * @param regMockHeapPtr   the pointer to the heap head, from which point on, the memory space
     *                          is free and can be used to locate data.
     * @param regDataToExport  the register pointing to the exporting data
     * @param type             the data type of the exporting data
     */
    def void exportMetaData(String regMockStackPtr, String regMockHeapPtr,
                            String regDataToExport, Type type) {

        // regMockHeapPtr = max(regMockHeapPtr, regMockStackPtr + dataSize)
        var temp = getFreeGpr
        genInsnAddConst(temp, regMockStackPtr, dataSize(type))

        var k = arrayIndex++
        var strHeapLabel = "UPDATE_FADDR_" + k
        genInsnGotoLabelUponCmp(regMockHeapPtr, '>=', temp, strHeapLabel)

        // update the mock heap pointer
        genInsnMovReg(regMockHeapPtr, temp)

        genQasmLabel(strHeapLabel)

        if (type instanceof TupleType) {
            var ttype = (type as TupleType).type
            for (ele : ttype) {
                exportMetaData(regMockStackPtr, regMockHeapPtr, regDataToExport, ele)
                genInsnAddConst(regMockStackPtr, dataSize(ele))
                genInsnAddConst(regDataToExport, dataSize(ele))
            }

        } 
        else if (type instanceof ArrayType) {
            genInsnForArith(temp, regMockHeapPtr, '-', regMockStackPtr)
            storeRegToMem(type, temp, 0, regMockStackPtr)

            var rarray = getFreeGpr
            loadMemToReg(type, rarray, 0, regDataToExport)

            var length = getFreeGpr
            loadMemToReg(length, 0, rarray)

            storeRegToMem(length, 0, regMockHeapPtr)

            // Update the pointers
            var tarray = getFreeGpr
            genInsnAddConst(tarray, regMockHeapPtr, Serializer.INT_SIZE)

            genInsnAddConst(rarray, Serializer.INT_SIZE)

            var ptype = getArrayElementType(type) // (type as ArrayType).ptype
            var psize = dataSize(ptype)
            loadImmToReg(strToGPR(temp), psize)

            genInsnMulRegs(temp, temp, length)
            genInsnAddRegs(regMockHeapPtr, regMockHeapPtr, temp)
            genInsnAddConst(regMockHeapPtr, Serializer.INT_SIZE)

            genInsnResetRegToZero(temp)

            val strArrLabel = genArrStartLabel(k)
            val strArrEndLabel = genArrEndLabel(k)
            genQasmLabel(strArrLabel)

            genInsnGotoLabelUponCmp(temp, '>=', length, strArrEndLabel)

            exportMetaData(tarray, regMockHeapPtr, rarray, ptype)
            genInsnAddConst(tarray, psize)
            genInsnAddConst(rarray, psize)

            genInsnAddConst(temp, 1)    // index = index + 1

            insertQasmGoto(strArrLabel)
            genQasmLabel(strArrEndLabel)
        } 
        else { // primitive types
            loadMemToReg (type, temp, 0, regDataToExport)
            storeRegToMem(type, temp, 0, regMockStackPtr)
        }
    }
    // ----------------------------------------------------------------------------------
    // end of serialization
    // ----------------------------------------------------------------------------------

    // ----------------------------------------------------------------------------------
    // start of the eQASM instruction region
    // ----------------------------------------------------------------------------------

    /**
     * Store the address of the heap top to a register.
     * 
     * @param regTarget  the name of the register
     * @return           null
     */
    def loadHeapPtrToReg(String regTarget) {
        var insn = genInsnMovReg(regTarget, 'r2')
        insn.setTrailingComment('load heap pointer')
    }

    /**
     * Store all the register to memory
     * 
     * @return  null
     */
    def flushAllRegsToMem() {
        genQasmComment('Clean the registers')
        for (m : mapRegToMetadata.values) { 
        	m.storeToMem
        }
        genQasmComment('End of register clean')
    }

    /**
     * Store a set of variable in memory.
     * 
     * @param strVarName  the names of the variable
     * @param map         symbol table of current operation
     * @param onlyMem     whether to disable values in MetaData (constant) or the memory (reg)
     * @return            null
     */
    def storeVarsToMem(HashSet<String> setVarNames, HashMap<String, MetaData> map, Boolean onlyMem) {
        for (variable: setVarNames) {
            variable.storeToMem(map, onlyMem)
        }
    }

    /**
     * Convert a Float parameter to eQASM style.
     * 
     * @param opName  the names of the variable
     * @param param   the value of the parameter
     * @return        the generated eQASM instruction op
     */
    def genOpNameWithParam(String opName, Float param) {
        var Float absParam
        var String mSign
        if (param >= 0) {
            mSign = ''
            absParam = param
        } 
        else {
            mSign = 'm'
            absParam = -param
        }

        return opName + mSign + absParam.toString.replace('.', '_')
    }

    /**
     * Generate the eQASM instructions of the measurement operation.
     * 
     * @param MsmtEqasmName  the eQASM instruction name of the measurement operation
     * @param regQotrs       the register of the qubit
     * @param iMsmtDuration  the duration of the measurement operation
     * @return               a metaData containing the measurement result
     */
    def genInsnForMsmt(String MsmtEqasmName, String regQotrs, int iMsmtDuration) {
        genInsnSQOperation(1, MsmtEqasmName, regQotrs)
        genInsnWait(iMsmtDuration - 3)
        genInsnWait(1)
        genInsnWait(1)
        genInsnWait(1)

        var regMsmtRes = allocRegister
        genInsnFetchMsmtRes(regMsmtRes, regQotrs.replace('s', 'q'))

        var metaMsmtRes = new MetaData(regMsmtRes)
        metaMsmtRes.valid.setOnlyReg
        metaMsmtRes.type = QuingoBoolType
        return metaMsmtRes
    }

    // ----------------------------------------------------------------------------------
    // end of the eQASM instruction region
    // ----------------------------------------------------------------------------------

    // ----------------------------------------------------------------------------------
    // start of various labels
    // ----------------------------------------------------------------------------------

    def genFuncEndLabel(int index) {
        return "function_" + index + "_end"
    }

    def genLoopStartLabel(int index) {
        return "labelwhile_" + index
    }

    def genLoopEndLabel(int index) {
        return "continue_" + index
    }

    def genIfElseLabel(int index) {
        return "ne_path_" + index
    }

    def genIfEndLabel(int index) {
        return "if_" + index + "_end"
    }

    def genArrStartLabel(int index) {
        return "ARRAY_" + index
    }
    
    def genArrEndLabel(int index) {
        return "ARRAY_" + index + "_END"
    }

    def genCaseStartLabel(int switch_index, int case_index) {
        return "switch_" + switch_index + "_" + case_index
    }

    def genCaseEndLabel(int switch_index, int case_index) {
        return "switch_" + switch_index + "_" + case_index + "_end"
    }

    // ----------------------------------------------------------------------------------
    // end of various labels
    // ----------------------------------------------------------------------------------

    // ----------------------------------------------------------------------------------
    // Utilities
    // ----------------------------------------------------------------------------------
    /**
     * Get the {@code Type} of an {@code Expression}.
     * 
     * @param expr  the Expression to be analyzed
     * @return      the Type of the input Expression
     */
    def getQuingoTypeOfExpr(Expression expr) {
        return xsemantics.exptype(expr).value
    }

    /**
     * Return a deep copy of a {@code Type}.
     * 
     * @param type  the original Type
     * @return      the copy of the input Type
     */
    def copyQuingoType(Type type) {
        return xsemantics.copytype(type).value
    }

    /**
     * Write generated eQASM instructions to file.
     * 
     * @return  null
     */
    def writeInsnToFile() {
        writeInsnToFile(fsaGlobal, fileName)
    }

    /**
     * Convert an Object into int.
     * 
     * @param value  the input Object
     * @return       the converted value
     */
    def convToInt(Object value) {
        return (value as Integer).intValue
    }

    /**
     * Get the type of the elements in an array.
     * 
     * @param type  the Type of the array
     * @return      the Type of the element
     */
    def getArrayElementType(Type type) {
        return (type as ArrayType).ptype
    }

    /**
     * Fetch a value in the configuration.
     * 
     * @param item   the name of the configuration item, such as "X"
     * @param field  the name of the query field, such as "type"
     * @return       the value corresponding to the query field, either a string or an integer
     */
    def fetchConfig(String item, String field) {
        var opaque = config.get(item)
        if (opaque === null) {
            throw new IOException("[fetchConfig] Cannot find the configuration for " + item)
        }
        for (sec: opaque.field) {
            if (sec.name.equals(field)) {
                return sec.value.string ?: sec.value.inti / 20
            }
        }
    }

    /**
     * Convert a {@code Type} to a string.
     * 
     * @param type  a {@code Type}
     * @return      the converted string
     */
    def String convTypeToStr(Type type) {
        if (type instanceof IntType) { 
        	return 'int'
        }
        else if (type instanceof BoolType) { 
        	return 'bool'
        }
        else if (type instanceof DoubleType) { 
        	return 'double'
        }
        else if (type instanceof TupleType) {
            var elementTypes = (type as TupleType).type
            var strElements = String.join(',', elementTypes.map[convTypeToStr(it)])
            return '(' + strElements + ')'
        }
        else if (type instanceof ArrayType) { 
        	return convTypeToStr(getArrayElementType(type)) + '[]'
        }

        throw new Exception('Found an unsupported type.')
    }

    /**
     * Read the integer value from its string representation `intStr`.
     * 
     * @param intStr  a string representing an integer
     * @return        the converted integer
     */
    def intFromString(String intStr) {
        try {
            val Integer intValue = new Integer(intStr)
            return intValue
        } 
        catch(Exception e) {
            var errMsg = String.format(
                "Error happens while coverting the following string into an integer: %s", intStr)
            System.err.println(errMsg)
            e.printStackTrace()
            throw new Exception(errMsg)
        }
    }

    /**
     * Check whether a block contains Break or Continue statements.
     * 
     * @param block  a BlockStatement
     * @return       whether the block contains Break or Continue statements
     */
	def Boolean containBreakOrContinue(BlockStatement block) {
		for (stat: block.stats) {
			if (stat instanceof BreakStatement) {
				return true
			}
			else if (stat instanceof ContinueStatement) {
				return true
			}
			else if (stat instanceof BlockStatement) {
				if (stat.containBreakOrContinue) {
					return true
				}
			}
			else if (stat instanceof IfStatement) {
				if (stat.ifStat.containBreakOrContinue || stat.elseStat?.containBreakOrContinue) {
					return true
				}
			}
			else if (stat instanceof UsingStatement) {
				if (stat.block.containBreakOrContinue) {
					return true
				}
			}
		}
		return false
	}
}
