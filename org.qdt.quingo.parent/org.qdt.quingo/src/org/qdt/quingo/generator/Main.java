/*
 * generated by Xtext 2.20.0
 */
package org.qdt.quingo.generator;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.generator.GeneratorContext;
import org.eclipse.xtext.generator.GeneratorDelegate;
import org.eclipse.xtext.generator.JavaIoFileSystemAccess;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;
import org.qdt.quingo.QuingoStandaloneSetup;
import org.qdt.quingo.quingo.AbstractElement;
import org.qdt.quingo.quingo.FunDeclaration;
import org.qdt.quingo.quingo.Program;

/**
 * The wrapper of the command-line compiler.
 * 
 * @author Jintao Yu
 */
public class Main {

	/**
	 * Print the usage of the command-line compiler
	 */
	static void printUsage() {
		System.out.println("Usage: java -jar quingo.jar <Quingo_files> <configuration_file> [options]");
		System.out.println("Options: ");
		System.out.println("\t-o --output <STRING>     Set the output file name.");
		System.out.println("\t-s --shared-addr <INT>   Set the starting address of the return values.");
		System.out.println("\t-t --static-addr <INT>   Set the starting address for storing variables.");
		System.out.println("\t-d --dynamic-addr <INT>  Set the starting address for allocating arrays.");
		System.out.println("\t-u --max-unroll <INT>    Set the maximum number of loop unrolling.");
		System.out.println("\t-h --help                Print this help message.");
		System.out.println("\t-v --version             Print version information.");
	}

	/**
	 * The entry point of the command-line compiler
	 */
	public static void main(String[] args) {
		
		// must specify files for compilation
		if (args.length == 0) {
			printUsage();
			System.exit(-1);
			return;
		}
		
		// process the injection
		Injector injector = new QuingoStandaloneSetup().createInjectorAndDoEMFRegistration();
		Main main = injector.getInstance(Main.class);
		
		// call the actual implementation
		int ret = main.runGenerator(args);
		if (ret != 0) {
			System.exit(ret);
		}
	}

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	@Inject
	private GeneratorDelegate generator;

	@Inject
	private JavaIoFileSystemAccess fileAccess;

	/**
	 * Process the command line and call the code generator
	 * <p>
	 * Summary of the exit status codes --
	 * 	  0: normal exit
	 *	 -1: syntax errors exist in source files
	 *	 -2: compilation failed (compiler finds errors in Quingo source files)
	 *	 -3: not find 'main' operation
	 *	 -4: compiler collapses (due to a bug in the source code)
	 *	 -5: command-line error
	 * 
	 * @param string  the command arguments
	 * @return        exit code
	 */
	protected int runGenerator(String[] string) {
		// The collection of all the source files
		ResourceSet set = resourceSetProvider.get();
		
		// List of all the resources
		List<Resource> all_resources = new ArrayList<Resource>();
		
		// The source file containing the main operation
		Resource mainRes = null;

		for (int i = 0; i < string.length; i++) {
			switch (string[i]) {
			case "-h":
			case "-H":
			case "--help":
				printUsage();
				return 0;
				
			case "-v":
			case "-V":
			case "--version":
				System.out.println("Quingo compiler v0.2.0.2");
				return 0;
				
			case "-o":
			case "-O":
			case "--ouput":
				if (++i >= string.length) {
					System.err.println("ERROR: -o or --output should be followed with a folder name!");
					return -5;
				}
				Configuration.outputFile = string[i];
				break;
				
			case "-s":
			case "-S":
			case "--shared-addr":
				if (++i >= string.length) {
					System.err.println("ERROR: -s or --shared-addr should be followed with an integer!");
					return -5;
				}
				try {
					Configuration.sharedAddr = Integer.parseInt(string[i]);
				}
				catch (Exception e) {
					e.printStackTrace();
					return -5;
				}
				break;
				
			case "-t":
			case "-T":
			case "--static-addr":
				if (++i >= string.length) {
					System.err.println("ERROR: -t or --static-addr should be followed with an integer!");
					return -5;
				}
				try {
					Configuration.staticAddr = Integer.parseInt(string[i]);
				}
				catch (Exception e) {
					e.printStackTrace();
					return -5;
				}
				break;
				
			case "-d":
			case "-D":
			case "--dynamic-addr":
				if (++i >= string.length) {
					System.err.println("ERROR: -d or --dynamic-addr should be followed with an integer!");
					return -5;
				}
				try {
					Configuration.dynamicAddr = Integer.parseInt(string[i]);
				}
				catch (Exception e) {
					e.printStackTrace();
					return -5;
				}
				break;
				
			case "-u":
			case "-U":
			case "--max-unroll":
				if (++i >= string.length) {
					System.err.println("ERROR: -u or --max-unroll should be followed with an integer!");
					return -5;
				}
				try {
					Configuration.maxUnrolling = Integer.parseInt(string[i]);
				}
				catch (Exception e) {
					e.printStackTrace();
					return -5;
				}
				break;
				
			default:
				if (string[i].charAt(0) == '-') {
					System.err.println("ERROR: unrecognized option!");
					return -5;
				}
				
				if (!string[i].endsWith(".qu") && !string[i].endsWith(".qfg")) {
					System.err.println("ERROR: unrecognized file format!");
					return -5;
				}
				
				// separate the file containing the 'main' operation from other files
				if (mainRes == null) {
					mainRes = set.getResource(URI.createFileURI(string[i]), true);
			        all_resources.add(mainRes);
				} 
				else {
			        Resource resource = set.getResource(URI.createFileURI(string[i]), true);
			        all_resources.add(resource);
		    	}
			}
		}

	    // Validate the syntax of the source files
	    for (Resource r: all_resources) {
	        List<Issue> list = validator.validate(r, CheckMode.ALL, CancelIndicator.NullImpl);
	        if (!list.isEmpty()) {
	            for (Issue issue : list) {
	                System.err.println(issue);
	            }
	            return -1;
	        }
	    }

	    // check whether the 'main' operation exist
		Program prog = (Program)mainRes.getContents().get(0);
		if (prog == null) {
			System.err.println("ERROR: Not found main operation!");
			return -3;
		}
		Boolean found = false;
		for (AbstractElement ele : prog.getElements()) {
			if (ele != null) {
				FunDeclaration fun = (FunDeclaration) ele.getFun();
				if (fun != null && fun.getName().equals("main")) {
					found = true;
				}
			}
		}
		if (!found) {
			return -3;
		}

		// Set output folder
		if (Configuration.outputFile.equals("")) {
			fileAccess.setOutputPath(".");
		}
		else {
			File file = new File(Configuration.outputFile);
			String absolutePath = file.getAbsolutePath();
			int index = absolutePath.lastIndexOf(File.separator);
			String folder = absolutePath.substring(0, index);
			Configuration.outputFile = absolutePath.substring(index + 1);
			fileAccess.setOutputPath(folder);
		}

		// Configure and start the generator
		GeneratorContext context = new GeneratorContext();
		context.setCancelIndicator(CancelIndicator.NullImpl);
		try {
			generator.doGenerate(all_resources.get(0), fileAccess, context);
		}
		catch (Exception e) {
			e.printStackTrace();
			return -4;
		}

		System.out.println("Code generation finished.");
		return Configuration.exitCode;
	}
}

